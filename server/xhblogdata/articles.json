{ "_id" : { "$oid" : "5d9209338fc2343e388471d7" }, "title_page_img" : "titlepimg/title_page_img_01.jpg", "views" : 68, "title" : "DNS预解析", "author" : " 梁凤波", "label" : { "$oid" : "5d9201466d6c3958a0c5add5" }, "article" : "# DNS prefetch\n向浏览器输入一个 URL 后，首先会进行 DNS 解析为对应的 IP 地址，DNS解析是一个漫长的过程，可以使用 DNS 缓存和 DNS prefetch 来优化。\n\nDNS 缓存查询机制：解析之前会查询缓存试得到 IP 地址，查询缓存的顺序为：\n浏览器缓存 ——> hosts系统缓存 ——> 路由器缓存 ——> ISP（互联网服务提供商）DNS缓存，如果没有缓存就继续递归查询 ——> 根域名服务器 ——> 顶级域名服务器 ——> 主域名服务器 ——> 保存结果至缓存；如果提前设置了 DNS 缓存，那么也减少了查询的步骤。\n\nDNS prefetch 的原理：开启了DNS prefetch后，浏览器在空闲时间会提前把这些域名转换为对应的 IP 地址，缓存到系统缓存中，从而缩短 DNS 解析花费的时间，提高访问网站的速度，以下是设置 DNS prefetch 的方式：\n```language\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>DNS prefetch</title>\n    <!-- 开启DNS预解析 -->\n    <meta http-equiv=\"x-dns-prefetch-control\" content=\"on\">\n    <link rel=\"dns-prefetch\" href=\"//cdn.boblog.com\">\n    <link rel=\"dns-prefetch\" href=\"//images.boblog.com\">\n</head>\n<body>\n</body>\n</html>\n\n```\n\n", "article_html" : "<h1 id=\"dns-prefetch\">DNS prefetch</h1>\n<p>向浏览器输入一个 URL 后，首先会进行 DNS 解析为对应的 IP 地址，DNS解析是一个漫长的过程，可以使用 DNS 缓存和 DNS prefetch 来优化。</p>\n<p>DNS 缓存查询机制：解析之前会查询缓存试得到 IP 地址，查询缓存的顺序为：\n浏览器缓存 ——&gt; hosts系统缓存 ——&gt; 路由器缓存 ——&gt; ISP（互联网服务提供商）DNS缓存，如果没有缓存就继续递归查询 ——&gt; 根域名服务器 ——&gt; 顶级域名服务器 ——&gt; 主域名服务器 ——&gt; 保存结果至缓存；如果提前设置了 DNS 缓存，那么也减少了查询的步骤。</p>\n<p>DNS prefetch 的原理：开启了DNS prefetch后，浏览器在空闲时间会提前把这些域名转换为对应的 IP 地址，缓存到系统缓存中，从而缩短 DNS 解析花费的时间，提高访问网站的速度，以下是设置 DNS prefetch 的方式：</p>\n<pre><code class=\"language-language\">&lt;!doctype html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;DNS prefetch&lt;/title&gt;\n    &lt;!-- 开启DNS预解析 --&gt;\n    &lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;\n    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cdn.boblog.com&quot;&gt;\n    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//images.boblog.com&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n", "createdAt" : { "$date" : "2019-09-30T13:54:59.555+0000" }, "updatedAt" : { "$date" : "2019-10-06T15:09:49.595+0000" }, "__v" : 0, "commentnum" : 2, "intro" : "向浏览器输入一个 URL 后，首先会进行 DNS 解析为对应的 IP 地址，DNS解析是一个漫长的过程，可以使用 DNS 缓存和 DNS prefetch 来优化。" }
{ "_id" : { "$oid" : "5d920bb38fc2343e388471d8" }, "title_page_img" : "titlepimg/title_page_img_02.jpg", "views" : 8, "title" : "理解JavaScript执行上下文", "author" : " 梁凤波", "label" : { "$oid" : "5d9201466d6c3958a0c5add3" }, "article" : "# 执行上下文\n执行上下文指当前的执行环境中的，变量、函数声明，参数，作用域链和this等信息。\n\n包含2个上下文：\n\n全局执行上下文（只有一个）\n函数执行上下文（每次调用函数都会创建一个新的上下文）\n包含的3个重要属性：\n\n变量对象（VO）\n作用域链（Scope Chain）\nthis\n```language\nconst ExecutionContext = {\n    VO: window, // 变量对象\n    ScopeChain: {}, // 作用域链\n    this: window\n};\n```\n# 执行上下文栈\nJS引擎首先会创建一个执行上下文栈，作用是管理上下文。在JS解释器初始化时首先创建一个全局上下文且压入上下文栈顶中，随着遇到函数调用时，会创建一个新的函数执行上下文且压入到上下文栈顶中，随着函数执行完后，会被上下文栈顶弹出，直回到全局上下文。\n```language\nvar a = 10;\n\nfunction fn2() {\n    console.log('fn2');\n}\n\nfunction fn1() {\n    fn2();\n    console.log('fn1');\n}\n\nfn1();\n\n// 模拟：创建一个上下文栈\nlet ECStack = [];\n\n// 首先是创建了一个全局上下文压到上下文栈顶中\nECStack.push('globalContext'); // => ['globalContext']\n\n// 然后遇到了fn1函数调用，创建fn1的上下文，且把fn1压入上下文栈顶中\nECStack.push(\"fn1Context\"); // => ['globalContext', 'fn1Context']\n\n// fn1里面也执行了fn2的函数，由此创建了f2的上下文，且把fn2上下文压入上下文栈顶中\nECStack.push(\"fn2Context\"); // => ['globalContext', 'fn1Context', 'fn2Context']\n\n// 执行完fn2函数后，fn2上下文从栈顶弹出\nECStack.pop(); // 弹出fn2Context => ['globalContext', 'fn1Context']\n\n// fn2弹出后，回到了fn1函数执行完后，fn1上下文从栈顶弹出\nECStack.pop(); // 弹出fn1Context => ['globalContext']\n\nconsole.log(ECStack); // ['globalContext']\n// 最后，ECStack底层一直存在着全局上下文 globalContext\n```\n# 执行上下文的生命周期\n执行上下文的生命周期分为2个：创建和执行。\n\n创建阶段：\n创建变量对象\n建立作用域链\n确定 this 的指向\n执行阶段：\n变量的赋值\n函数的引用\n执行其他的代码\n执行完毕后，从上下文栈顶弹出，等待回收\n# 变量对象\n变量对象指上下文中的数据作用域，储存着上下文的变量和函数声明。变量对象的工作也分为2种阶段：进入上下文和代码执行。\n\n进入上下文阶段：\n如果是函数上下文，会处理函数参数：如果没有传入，则初始化参数值为undefined\n函数声明：如果发生函数名字相同，则后者会覆盖前者\n变量声明：初始化变量为undefined，如果发生与其他变量或者函数声明同名，则会忽略\n代码执行阶段：\n按顺序执行，进行修改赋值\n```language\n// 代码示例：\nconsole.log(x); // function x() {}\n\nvar x = 10;\nconsole.log(x); // 10\n\nx = 20;\n\nfunction x() {\n}\n\nconsole.log(x); // 20\n\nif (true) {\n    var a = 30;\n} else {\n    var b = 40;\n}\nconsole.log(a); // 30\nconsole.log(b); // undefined\n\n// 进入执行上下文阶段后的VO\nvar VO = {\n    x: 'reference to function x() {}',\n    a: undefined,\n    b: undefined\n}\n\n// 执行代码完阶段后的VO\nvar VO = {\n    x: 20,\n    a: 30,\n    b: undefined\n}\n```\n> 未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。它们其实都是同一个对象，只是处于执行上下文的不同生命周期。\n#参考资料\n[JavaScript深入之变量对象](https://github.com/mqyqingfeng/Blog/issues/5), by mqyqingfeng\n\n", "article_html" : "<h1 id=\"执行上下文\">执行上下文</h1>\n<p>执行上下文指当前的执行环境中的，变量、函数声明，参数，作用域链和this等信息。</p>\n<p>包含2个上下文：</p>\n<p>全局执行上下文（只有一个）\n函数执行上下文（每次调用函数都会创建一个新的上下文）\n包含的3个重要属性：</p>\n<p>变量对象（VO）\n作用域链（Scope Chain）\nthis</p>\n<pre><code class=\"language-language\">const ExecutionContext = {\n    VO: window, // 变量对象\n    ScopeChain: {}, // 作用域链\n    this: window\n};</code></pre>\n<h1 id=\"执行上下文栈\">执行上下文栈</h1>\n<p>JS引擎首先会创建一个执行上下文栈，作用是管理上下文。在JS解释器初始化时首先创建一个全局上下文且压入上下文栈顶中，随着遇到函数调用时，会创建一个新的函数执行上下文且压入到上下文栈顶中，随着函数执行完后，会被上下文栈顶弹出，直回到全局上下文。</p>\n<pre><code class=\"language-language\">var a = 10;\n\nfunction fn2() {\n    console.log(&#39;fn2&#39;);\n}\n\nfunction fn1() {\n    fn2();\n    console.log(&#39;fn1&#39;);\n}\n\nfn1();\n\n// 模拟：创建一个上下文栈\nlet ECStack = [];\n\n// 首先是创建了一个全局上下文压到上下文栈顶中\nECStack.push(&#39;globalContext&#39;); // =&gt; [&#39;globalContext&#39;]\n\n// 然后遇到了fn1函数调用，创建fn1的上下文，且把fn1压入上下文栈顶中\nECStack.push(&quot;fn1Context&quot;); // =&gt; [&#39;globalContext&#39;, &#39;fn1Context&#39;]\n\n// fn1里面也执行了fn2的函数，由此创建了f2的上下文，且把fn2上下文压入上下文栈顶中\nECStack.push(&quot;fn2Context&quot;); // =&gt; [&#39;globalContext&#39;, &#39;fn1Context&#39;, &#39;fn2Context&#39;]\n\n// 执行完fn2函数后，fn2上下文从栈顶弹出\nECStack.pop(); // 弹出fn2Context =&gt; [&#39;globalContext&#39;, &#39;fn1Context&#39;]\n\n// fn2弹出后，回到了fn1函数执行完后，fn1上下文从栈顶弹出\nECStack.pop(); // 弹出fn1Context =&gt; [&#39;globalContext&#39;]\n\nconsole.log(ECStack); // [&#39;globalContext&#39;]\n// 最后，ECStack底层一直存在着全局上下文 globalContext</code></pre>\n<h1 id=\"执行上下文的生命周期\">执行上下文的生命周期</h1>\n<p>执行上下文的生命周期分为2个：创建和执行。</p>\n<p>创建阶段：\n创建变量对象\n建立作用域链\n确定 this 的指向\n执行阶段：\n变量的赋值\n函数的引用\n执行其他的代码\n执行完毕后，从上下文栈顶弹出，等待回收</p>\n<h1 id=\"变量对象\">变量对象</h1>\n<p>变量对象指上下文中的数据作用域，储存着上下文的变量和函数声明。变量对象的工作也分为2种阶段：进入上下文和代码执行。</p>\n<p>进入上下文阶段：\n如果是函数上下文，会处理函数参数：如果没有传入，则初始化参数值为undefined\n函数声明：如果发生函数名字相同，则后者会覆盖前者\n变量声明：初始化变量为undefined，如果发生与其他变量或者函数声明同名，则会忽略\n代码执行阶段：\n按顺序执行，进行修改赋值</p>\n<pre><code class=\"language-language\">// 代码示例：\nconsole.log(x); // function x() {}\n\nvar x = 10;\nconsole.log(x); // 10\n\nx = 20;\n\nfunction x() {\n}\n\nconsole.log(x); // 20\n\nif (true) {\n    var a = 30;\n} else {\n    var b = 40;\n}\nconsole.log(a); // 30\nconsole.log(b); // undefined\n\n// 进入执行上下文阶段后的VO\nvar VO = {\n    x: &#39;reference to function x() {}&#39;,\n    a: undefined,\n    b: undefined\n}\n\n// 执行代码完阶段后的VO\nvar VO = {\n    x: 20,\n    a: 30,\n    b: undefined\n}</code></pre>\n<blockquote>\n<p>未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。它们其实都是同一个对象，只是处于执行上下文的不同生命周期。\n#参考资料\n<a href=\"https://github.com/mqyqingfeng/Blog/issues/5\">JavaScript深入之变量对象</a>, by mqyqingfeng</p>\n</blockquote>\n", "createdAt" : { "$date" : "2019-09-30T14:05:39.619+0000" }, "updatedAt" : { "$date" : "2019-10-05T16:07:10.219+0000" }, "__v" : 0, "commentnum" : 1, "intro" : "JS引擎首先会创建一个执行上下文栈，作用是管理上下文。在JS解释器初始化时首先创建一个全局上下文且压入上下文栈顶中，随着遇到函数调用时，会创建一个新的函数执行上下文且压入到上下文栈顶中，随着函数执行完后，会被上下文栈顶弹出，直回到全局上下文。" }
{ "_id" : { "$oid" : "5d920c598fc2343e388471d9" }, "title_page_img" : "titlepimg/title_page_img_03.jpg", "views" : 6, "title" : "ES6解构-对象解构", "author" : " 梁凤波", "label" : { "$oid" : "5d9201466d6c3958a0c5add3" }, "article" : "# 解构\n使数据访问更便捷\n\n# 对象解构\n取对象的值：\n```language\nlet user = {\n    name: 'bobobo',\n    email: 'itbo@163.com'\n}\n\n// 取 name 和 email 属性\nlet {name, email} = user;\n\n// 如果对象 node 中没有 jobs 属性\nlet {name, email, jobs} = user;\n// 那么 jobs 的值是 undefined，当然也可以赋默认值\nlet {name, email, jobs = 'codingmonkey'} = user;\n\n// 解构取值且重新命名\nlet {name: username, email: workEmail} = user;\n\n// 解构取值且重新命名且赋默认值\nlet {name: username, email: workEmail, jobs: myjobs = 'codingmonkey@yeah.net'} = user;\n```\n嵌套对象解构取值：\n```language\nlet node = {\n    local: {\n        start: {\n            line: 1,\n            column: 1\n        },\n        end: {\n            line: 10,\n            column: 10\n        }\n    }\n};\n\n// 取嵌套的 start 对象\nlet {local: {start}} = node;\nconsole.log(start.line); // 1\nconsole.log(start.column); // 1\n\n// 取嵌套的 end 对象\nlet {local: {end}} = node;\nconsole.log(end.line); // 10\nconsole.log(end.column); // 10\n\n// 取嵌套的 start 对象 且重新命名\nlet {local: {start: localStart}} = node;\nconsole.log(localStart.line); // 1\nconsole.log(localStart.column); // 1\n\n// 取嵌套不存在的 middle 对象且赋值默认值\nlet {local: {middle = {line: 5, column: 5}}} = node;\nconsole.log(middle.line); // 5\nconsole.log(middle.column); // 5\n```\n", "article_html" : "<h1 id=\"解构\">解构</h1>\n<p>使数据访问更便捷</p>\n<h1 id=\"对象解构\">对象解构</h1>\n<p>取对象的值：</p>\n<pre><code class=\"language-language\">let user = {\n    name: &#39;bobobo&#39;,\n    email: &#39;itbo@163.com&#39;\n}\n\n// 取 name 和 email 属性\nlet {name, email} = user;\n\n// 如果对象 node 中没有 jobs 属性\nlet {name, email, jobs} = user;\n// 那么 jobs 的值是 undefined，当然也可以赋默认值\nlet {name, email, jobs = &#39;codingmonkey&#39;} = user;\n\n// 解构取值且重新命名\nlet {name: username, email: workEmail} = user;\n\n// 解构取值且重新命名且赋默认值\nlet {name: username, email: workEmail, jobs: myjobs = &#39;codingmonkey@yeah.net&#39;} = user;</code></pre>\n<p>嵌套对象解构取值：</p>\n<pre><code class=\"language-language\">let node = {\n    local: {\n        start: {\n            line: 1,\n            column: 1\n        },\n        end: {\n            line: 10,\n            column: 10\n        }\n    }\n};\n\n// 取嵌套的 start 对象\nlet {local: {start}} = node;\nconsole.log(start.line); // 1\nconsole.log(start.column); // 1\n\n// 取嵌套的 end 对象\nlet {local: {end}} = node;\nconsole.log(end.line); // 10\nconsole.log(end.column); // 10\n\n// 取嵌套的 start 对象 且重新命名\nlet {local: {start: localStart}} = node;\nconsole.log(localStart.line); // 1\nconsole.log(localStart.column); // 1\n\n// 取嵌套不存在的 middle 对象且赋值默认值\nlet {local: {middle = {line: 5, column: 5}}} = node;\nconsole.log(middle.line); // 5\nconsole.log(middle.column); // 5</code></pre>\n", "createdAt" : { "$date" : "2019-09-30T14:08:25.146+0000" }, "updatedAt" : { "$date" : "2019-10-11T16:29:35.355+0000" }, "__v" : 0, "commentnum" : 0, "intro" : "我们经常定义许多对象和数组，然后有组织地从中提取相关的信息片段。在ES6中添加了可以简化这种任务的新特性：解构。解构是一种打破数据结构，将其拆分为更小部分的过程。本文将详细介绍ES6解构赋值" }
{ "_id" : { "$oid" : "5d920dca8fc2343e388471da" }, "title_page_img" : "titlepimg/title_page_img_04.jpg", "views" : 12, "title" : "es6中新增数组的方法", "author" : "Mrxh", "label" : { "$oid" : "5d9201466d6c3958a0c5add3" }, "article" : "# 1. Array.from\n这个东西就是把一些集合，或者长的像数组的伪数组转换成真的数组，比如arguments，js选择器找到dom集合,\n还有对象模拟的数组\n```lang\nvar obj = {\n'0' : 1,\nlength : 1\n}\nArray.from(obj / arguments / 伪数组) //返回的是一个数组\n[].slice.call(arguments, 0) //这种方式根from方法是一样的效果\n\n//Array.from还有第二个参数，是一个回掉函数，功能类似map\nArray.from( [1, 2, 3], item => item * 2 )\n\n```\n\n# 2. Array.of\n```\nArray.of(1, 2, 3, 4)    //把参数合并成一个数组返回，如果参数为空，则返回一个空数组\n```\n\n\n# 3. copyWithin\n```\n//这个东西用的不多，但是很有意思\n//首先，参数有3个\n//1: 被替换的起始位置   2: 选取替换值的起始位置   3: 选取替换值得结束位置\nlet arr = [1, 'c', 'd', 'a', 'b'];  //假如我想把a，b替换到1的位置\narr.copyWithin(0, 3, 5)   // [\"a\", \"b\", \"d\", \"a\", \"b\"]\n\n```\n\n# 4. find/findIndex\n```\n//find  返回数组中第一个符合条件的元素, findIndex返回索引\n[1, 2, 3, 4, 5].find(function(item){\n    return item > 3\n})\n```\n# 5. fill\n```\n//功能一： 字面意思填满，实际功能就是把数组中的每一个元素替换成指定值\nlet arr = [1, 2, 3, 4]\narr.fill(5)        //arr全变成了5\n//功能二：指定范围替换，这功能似曾相识啊\narr.fill(6, 1, 3) //使用6 替换数组中 下表为1-3范围的值， 范围是下标>=1 && <3 的位置。\n//猛的一看以为功能和splice一样呢，又去巩固了一下。splice是删除某一个元素，然后增加指定的个数，并且它第一个参数是下标起点，第二个参数是个数，而不是结束下标。\n\n//扩展\n[].fill.call( { length : 3 }, 4)  //结果为以为是数组，每个元素是4，结果返回的竟然还是对象。。。\n```\n\n# 6. entries/keys/values\n```\nlet arr=['a', 'b', 'c']\nfor(let key of arr.keys()){}                     //取键\nfor(let value of arr.values()){}                //取值；不能直接使用，有兼容性问题，甚至谷歌\nfor(let [key, value] of arr.entries()){}       //都取\n```\n# 7.inludes\n```\nvar a = function(){}\n[1, 2, 3, 4, a].includes(a)    //true\n[1, 2, 3, 4, NaN].includes(NaN)    //true\n```", "article_html" : "<h1 id=\"1-arrayfrom\">1. Array.from</h1>\n<p>这个东西就是把一些集合，或者长的像数组的伪数组转换成真的数组，比如arguments，js选择器找到dom集合,\n还有对象模拟的数组</p>\n<pre><code class=\"language-lang\">var obj = {\n&#39;0&#39; : 1,\nlength : 1\n}\nArray.from(obj / arguments / 伪数组) //返回的是一个数组\n[].slice.call(arguments, 0) //这种方式根from方法是一样的效果\n\n//Array.from还有第二个参数，是一个回掉函数，功能类似map\nArray.from( [1, 2, 3], item =&gt; item * 2 )\n</code></pre>\n<h1 id=\"2-arrayof\">2. Array.of</h1>\n<pre><code>Array.of(1, 2, 3, 4)    //把参数合并成一个数组返回，如果参数为空，则返回一个空数组</code></pre><h1 id=\"3-copywithin\">3. copyWithin</h1>\n<pre><code>//这个东西用的不多，但是很有意思\n//首先，参数有3个\n//1: 被替换的起始位置   2: 选取替换值的起始位置   3: 选取替换值得结束位置\nlet arr = [1, &#39;c&#39;, &#39;d&#39;, &#39;a&#39;, &#39;b&#39;];  //假如我想把a，b替换到1的位置\narr.copyWithin(0, 3, 5)   // [&quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;a&quot;, &quot;b&quot;]\n</code></pre><h1 id=\"4-findfindindex\">4. find/findIndex</h1>\n<pre><code>//find  返回数组中第一个符合条件的元素, findIndex返回索引\n[1, 2, 3, 4, 5].find(function(item){\n    return item &gt; 3\n})</code></pre><h1 id=\"5-fill\">5. fill</h1>\n<pre><code>//功能一： 字面意思填满，实际功能就是把数组中的每一个元素替换成指定值\nlet arr = [1, 2, 3, 4]\narr.fill(5)        //arr全变成了5\n//功能二：指定范围替换，这功能似曾相识啊\narr.fill(6, 1, 3) //使用6 替换数组中 下表为1-3范围的值， 范围是下标&gt;=1 &amp;&amp; &lt;3 的位置。\n//猛的一看以为功能和splice一样呢，又去巩固了一下。splice是删除某一个元素，然后增加指定的个数，并且它第一个参数是下标起点，第二个参数是个数，而不是结束下标。\n\n//扩展\n[].fill.call( { length : 3 }, 4)  //结果为以为是数组，每个元素是4，结果返回的竟然还是对象。。。</code></pre><h1 id=\"6-entrieskeysvalues\">6. entries/keys/values</h1>\n<pre><code>let arr=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\nfor(let key of arr.keys()){}                     //取键\nfor(let value of arr.values()){}                //取值；不能直接使用，有兼容性问题，甚至谷歌\nfor(let [key, value] of arr.entries()){}       //都取</code></pre><h1 id=\"7inludes\">7.inludes</h1>\n<pre><code>var a = function(){}\n[1, 2, 3, 4, a].includes(a)    //true\n[1, 2, 3, 4, NaN].includes(NaN)    //true</code></pre>", "createdAt" : { "$date" : "2019-09-30T14:14:34.354+0000" }, "updatedAt" : { "$date" : "2019-10-09T14:04:56.591+0000" }, "__v" : 0, "commentnum" : 3, "intro" : "这个东西就是把一些集合，或者长的像数组的伪数组转换成真的数组，比如arguments，js选择器找到dom集合,还有对象模拟的数组" }
{ "_id" : { "$oid" : "5d92b234c8ad40548c9995f3" }, "title_page_img" : "titlepimg/title_page_img_05.jpg", "views" : 11, "commentnum" : 3, "title" : "ES6常用新特性总结", "author" : "TigerMr", "label" : { "$oid" : "5d9201466d6c3958a0c5add3" }, "article" : "# 1.let && const\nlet命令也用于声明对象，但是作用域为局部。\n```\n{\n    let a = 10;\n    var b = 1;\n}\n```\n在函数外部可以获取到b，获取不到a，因此例如for循环计数器就适合使用let。\n\nconst用于声明一个常量，设定后值不会再改变。\n```\nconst PI = 3.1415;\nPI // 3.1415\nPI = 3;\n```\n强行对其进行重新赋值会报错。\n\n# 2.iterable类型\n为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型，具有iterable类型的集合可以通过新的for … of循环来遍历。\n```\nvar a = ['A', 'B', 'C'];\nvar s = new Set(['A', 'B', 'C']);\nvar m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);\nfor (var x of a) { // 遍历Array\n    alert(x);\n}\nfor (var x of s) { // 遍历Set\n    alert(x);\n}\nfor (var x of m) { // 遍历Map\n    alert(x[0] + '=' + x[1]);\n}\n```\nMap相关操作方法如下，Set同理：\n```\nvar m = new Map(); // 空Map\nm.set('Adam', 67); // 添加新的key-value\nm.set('Bob', 59);\nm.has('Adam'); // 是否存在key 'Adam': true\nm.get('Adam'); // 67\nm.delete('Adam'); // 删除key 'Adam'\nm.get('Adam'); // undefined\n```\n# 3.解构赋值\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 \n例如数组：\n```\nlet [a, b, c] = [1, 2, 3];\n//等同于\nlet a = 1;\nlet b = 2;\nlet c = 3;\n```\n对象的解构赋值：获取对象的多个属性并且使用一条语句将它们赋给多个变量。\n```\nvar {\n  StyleSheet,\n  Text,\n  View\n} = React;\n```\n等同于\n```\nvar StyleSheet = React.StyleSheet\n```\n# 4.箭头函数\nES6中新增箭头操作符用于简化函数的写法，操作符左边为参数，右边为具体操作和返回值。\n```\nvar sum = (num1, num2) => { return num1 + num2; }\n//等同于\nvar sum = function(num1, num2) {\n    return num1 + num2;\n };\n```\n箭头函数还修复了this的指向，使其永远指向词法作用域：\n```\nvar obj = {\n    birth: 1990,\n    getAge: function () {\n        var b = this.birth; // 1990\n        var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象\n        return fn();\n    }\n};\nobj.getAge(); // 25\n```\n# 5.延展操作符\n通过它可以将数组作为参数直接传入函数：\n```\nvar people=['Wayou','John','Sherlock'];\nfunction sayHello(people1,people2,people3){\n    console.log(`Hello ${people1},${people2},${people3}`);\n}\n//改写为\nsayHello(...people);//输出：Hello Wayou,John,Sherlock \n```\n在函数定义时可以通过…rest获取定义参数外的所有参数：\n```\nfunction foo(a, b, ...rest) {\n    console.log('a = ' + a);\n    console.log('b = ' + b);\n    console.log(rest);\n}\n\nfoo(1, 2, 3, 4, 5);\n// 结果:\n// a = 1\n// b = 2\n// Array [ 3, 4, 5 ]\n```\n# 6.类\nES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类，与多数传统语言类似。\n```\n//定义类\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n```\n> 版权声明：本文为CSDN博主「TsingMr」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。", "article_html" : "<h1 id=\"1let--const\">1.let &amp;&amp; const</h1>\n<p>let命令也用于声明对象，但是作用域为局部。</p>\n<pre><code>{\n    let a = 10;\n    var b = 1;\n}</code></pre><p>在函数外部可以获取到b，获取不到a，因此例如for循环计数器就适合使用let。</p>\n<p>const用于声明一个常量，设定后值不会再改变。</p>\n<pre><code>const PI = 3.1415;\nPI // 3.1415\nPI = 3;</code></pre><p>强行对其进行重新赋值会报错。</p>\n<h1 id=\"2iterable类型\">2.iterable类型</h1>\n<p>为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型，具有iterable类型的集合可以通过新的for … of循环来遍历。</p>\n<pre><code>var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];\nvar s = new Set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]);\nvar m = new Map([[1, &#39;x&#39;], [2, &#39;y&#39;], [3, &#39;z&#39;]]);\nfor (var x of a) { // 遍历Array\n    alert(x);\n}\nfor (var x of s) { // 遍历Set\n    alert(x);\n}\nfor (var x of m) { // 遍历Map\n    alert(x[0] + &#39;=&#39; + x[1]);\n}</code></pre><p>Map相关操作方法如下，Set同理：</p>\n<pre><code>var m = new Map(); // 空Map\nm.set(&#39;Adam&#39;, 67); // 添加新的key-value\nm.set(&#39;Bob&#39;, 59);\nm.has(&#39;Adam&#39;); // 是否存在key &#39;Adam&#39;: true\nm.get(&#39;Adam&#39;); // 67\nm.delete(&#39;Adam&#39;); // 删除key &#39;Adam&#39;\nm.get(&#39;Adam&#39;); // undefined</code></pre><h1 id=\"3解构赋值\">3.解构赋值</h1>\n<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 \n例如数组：</p>\n<pre><code>let [a, b, c] = [1, 2, 3];\n//等同于\nlet a = 1;\nlet b = 2;\nlet c = 3;</code></pre><p>对象的解构赋值：获取对象的多个属性并且使用一条语句将它们赋给多个变量。</p>\n<pre><code>var {\n  StyleSheet,\n  Text,\n  View\n} = React;</code></pre><p>等同于</p>\n<pre><code>var StyleSheet = React.StyleSheet</code></pre><h1 id=\"4箭头函数\">4.箭头函数</h1>\n<p>ES6中新增箭头操作符用于简化函数的写法，操作符左边为参数，右边为具体操作和返回值。</p>\n<pre><code>var sum = (num1, num2) =&gt; { return num1 + num2; }\n//等同于\nvar sum = function(num1, num2) {\n    return num1 + num2;\n };</code></pre><p>箭头函数还修复了this的指向，使其永远指向词法作用域：</p>\n<pre><code>var obj = {\n    birth: 1990,\n    getAge: function () {\n        var b = this.birth; // 1990\n        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象\n        return fn();\n    }\n};\nobj.getAge(); // 25</code></pre><h1 id=\"5延展操作符\">5.延展操作符</h1>\n<p>通过它可以将数组作为参数直接传入函数：</p>\n<pre><code>var people=[&#39;Wayou&#39;,&#39;John&#39;,&#39;Sherlock&#39;];\nfunction sayHello(people1,people2,people3){\n    console.log(`Hello ${people1},${people2},${people3}`);\n}\n//改写为\nsayHello(...people);//输出：Hello Wayou,John,Sherlock </code></pre><p>在函数定义时可以通过…rest获取定义参数外的所有参数：</p>\n<pre><code>function foo(a, b, ...rest) {\n    console.log(&#39;a = &#39; + a);\n    console.log(&#39;b = &#39; + b);\n    console.log(rest);\n}\n\nfoo(1, 2, 3, 4, 5);\n// 结果:\n// a = 1\n// b = 2\n// Array [ 3, 4, 5 ]</code></pre><h1 id=\"6类\">6.类</h1>\n<p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类，与多数传统语言类似。</p>\n<pre><code>//定义类\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;\n  }\n}</code></pre><blockquote>\n<p>版权声明：本文为CSDN博主「TsingMr」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p>\n</blockquote>\n", "createdAt" : { "$date" : "2019-10-01T01:56:04.916+0000" }, "updatedAt" : { "$date" : "2019-10-09T14:05:58.789+0000" }, "__v" : 0, "intro" : "为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型，具有iterable类型的集合可以通过新的for … of循环来遍历。" }
{ "_id" : { "$oid" : "5d92b5eac8ad40548c9995f4" }, "title_page_img" : "titlepimg/title_page_img_06.jpg", "views" : 5, "commentnum" : 1, "title" : "Nuxt.js + koa2 入门", "author" : "Mrxh", "label" : { "$oid" : "5d9201466d6c3958a0c5add5" }, "article" : "# 1. nuxt项目初始化\n下面是使用 koa 模板方法初始化一个项目，使用该方法需要将 nuxt 的版本降至1.4.2；\n官方 [https://zh.nuxtjs.org/guide/installation](https://zh.nuxtjs.org/guide/installation) 还要提供了脚手架工具，可用使用最新的nuxt2.0版本初始化一个项目。\n```\n$ vue init nuxt-community/koa-template <project-name>\n$ cd <project-name>\n$ npm run dev\n<!--\n    1. 如果有报错： Plugin/Preset files are not allowed to export objects, only functions\n        需要降低nuxt版本至1.4.2：\n        npm uninstall nuxt\n        npm install nuxt@1.4.2\n        \n    2.  升级eslint-plugin-html \n        $ npm i eslint-plugin-html@^3\n-->\n```\n# 2. 新建路由\n(创建即配置)在pages目录中新建一个vue文件，即成功创建了路由，文件名也就是路由名称。\n\n# 3. 模板文件\nlayouts 目录下的所有文件都属于个性化布局文件，可以在页面组件中利用 layout 属性来引用。\n请确保在布局文件里面增加 组件用于显示页面非布局内容。\n举个例子：\n\n新建：layouts/search-layout.vue:\n```\n<template>\n  <div>\n    <h1>search page</h1>\n    <nuxt/>\n    <footer>这是一个自定义的只用于search的模板</footer>\n  </div>\n</template>\n<script>\nexport default {\n}\n</script>\n在 pages/search.vue 里， 可以指定页面组件使用 search-layout 布局。\n\n<template>\n  <div>\n    <h2>search page</h2>\n  </div>\n</template>\n<script>\nexport default {\n  layout: 'search-layout'\n}\n</script>  \n```\n4. 全局配置文件：nuxt.config.js\n这里面定义了所有页面的head title 和main.css 。。。等\n\n# 5. 接口路由配置\n### 5.1 在server目录新建interface/city.js\n```\nimport Router from 'koa-router'\n\nconst router = new Router({\n  prefix: '/city'\n})\nrouter.get('/list', async (ctx) => {\n  ctx.body = {\n    list: ['北京', '上海', '菏泽']\n  }\n})\n\nexport default router\n```\n### 5.2 在server/index.js中引入新建路由\n```\nimport Koa from 'koa'\nimport { Nuxt, Builder } from 'nuxt'\n\n// 引入新建接口路由\nimport cityInterface from './interface/city'\n// 使用新建接口路由\napp.use(cityInterface.routes()).use(cityInterface.allowedMethods())\n访问：http://localhost:3000/city/list 验证是否成功\n```\n### 5.3 从新建接口中获取数据\n```\n<template>\n  <div>\n    <h2>search page</h2>\n    <ul>\n      <li v-for=\"(item, index) in list\" :key=\"index\">\n        {{item}}\n      </li>\n    </ul>\n  </div>\n</template>\n<script>\nimport axios from 'axios'\nexport default {\n  layout: 'search-layout',\n  data() {\n    return {\n      list: ['11', '22', '33']\n    }\n  },\n  async mounted() {\n    let res = await axios.get('/city/list')\n    console.log(res)\n    this.list = res.data.list\n  }\n}\n</script>\n```", "article_html" : "<h1 id=\"1-nuxt项目初始化\">1. nuxt项目初始化</h1>\n<p>下面是使用 koa 模板方法初始化一个项目，使用该方法需要将 nuxt 的版本降至1.4.2；\n官方 <a href=\"https://zh.nuxtjs.org/guide/installation\">https://zh.nuxtjs.org/guide/installation</a> 还要提供了脚手架工具，可用使用最新的nuxt2.0版本初始化一个项目。</p>\n<pre><code>$ vue init nuxt-community/koa-template &lt;project-name&gt;\n$ cd &lt;project-name&gt;\n$ npm run dev\n&lt;!--\n    1. 如果有报错： Plugin/Preset files are not allowed to export objects, only functions\n        需要降低nuxt版本至1.4.2：\n        npm uninstall nuxt\n        npm install nuxt@1.4.2\n\n    2.  升级eslint-plugin-html \n        $ npm i eslint-plugin-html@^3\n--&gt;</code></pre><h1 id=\"2-新建路由\">2. 新建路由</h1>\n<p>(创建即配置)在pages目录中新建一个vue文件，即成功创建了路由，文件名也就是路由名称。</p>\n<h1 id=\"3-模板文件\">3. 模板文件</h1>\n<p>layouts 目录下的所有文件都属于个性化布局文件，可以在页面组件中利用 layout 属性来引用。\n请确保在布局文件里面增加 组件用于显示页面非布局内容。\n举个例子：</p>\n<p>新建：layouts/search-layout.vue:</p>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;search page&lt;/h1&gt;\n    &lt;nuxt/&gt;\n    &lt;footer&gt;这是一个自定义的只用于search的模板&lt;/footer&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n}\n&lt;/script&gt;\n在 pages/search.vue 里， 可以指定页面组件使用 search-layout 布局。\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h2&gt;search page&lt;/h2&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  layout: &#39;search-layout&#39;\n}\n&lt;/script&gt;  </code></pre><ol start=\"4\">\n<li>全局配置文件：nuxt.config.js\n这里面定义了所有页面的head title 和main.css 。。。等</li>\n</ol>\n<h1 id=\"5-接口路由配置\">5. 接口路由配置</h1>\n<h3 id=\"51-在server目录新建interfacecityjs\">5.1 在server目录新建interface/city.js</h3>\n<pre><code>import Router from &#39;koa-router&#39;\n\nconst router = new Router({\n  prefix: &#39;/city&#39;\n})\nrouter.get(&#39;/list&#39;, async (ctx) =&gt; {\n  ctx.body = {\n    list: [&#39;北京&#39;, &#39;上海&#39;, &#39;菏泽&#39;]\n  }\n})\n\nexport default router</code></pre><h3 id=\"52-在serverindexjs中引入新建路由\">5.2 在server/index.js中引入新建路由</h3>\n<pre><code>import Koa from &#39;koa&#39;\nimport { Nuxt, Builder } from &#39;nuxt&#39;\n\n// 引入新建接口路由\nimport cityInterface from &#39;./interface/city&#39;\n// 使用新建接口路由\napp.use(cityInterface.routes()).use(cityInterface.allowedMethods())\n访问：http://localhost:3000/city/list 验证是否成功</code></pre><h3 id=\"53-从新建接口中获取数据\">5.3 从新建接口中获取数据</h3>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;h2&gt;search page&lt;/h2&gt;\n    &lt;ul&gt;\n      &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;\n        {{item}}\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport axios from &#39;axios&#39;\nexport default {\n  layout: &#39;search-layout&#39;,\n  data() {\n    return {\n      list: [&#39;11&#39;, &#39;22&#39;, &#39;33&#39;]\n    }\n  },\n  async mounted() {\n    let res = await axios.get(&#39;/city/list&#39;)\n    console.log(res)\n    this.list = res.data.list\n  }\n}\n&lt;/script&gt;</code></pre>", "createdAt" : { "$date" : "2019-10-01T02:11:54.106+0000" }, "updatedAt" : { "$date" : "2019-10-09T15:32:55.678+0000" }, "__v" : 0, "intro" : "官方还要提供了脚手架工具，可用使用最新的nuxt2.0版本初始化一个项目。layouts 目录下的所有文件都属于个性化布局文件，可以在页面组件中利用 layout 属性来引用。" }
{ "_id" : { "$oid" : "5d935e5189e8db5af46eaa4f" }, "title_page_img" : "titlepimg/title_page_img_07.jpg", "views" : 7, "commentnum" : 1, "title" : "JS数组去重", "author" : "Mrxh", "label" : { "$oid" : "5d9201466d6c3958a0c5add3" }, "article" : "# 方法一\n优点：简单，性能好\n缺点1：在IE6-8下数组的indexOf方法不存在\n缺点2：相同的字符串类型数值和数字类型的数值不会去重\n```\nfunction unique(arr) {\n    var ret = [];\n\n    for (var i = 0; i < arr.length; i++) {\n        var item = arr[i];\n        if (ret.indexOf(item) === -1) {\n            ret.push(item);\n        }\n    }\n\n    return ret;\n}\n```\n# 方法二\n优化方法一：在IE6-8下数组的indexOf方法不存在时，手动添加indexOf实现方法\n缺点2：相同的字符串类型数值和数字类型的数值不会去重\n```\nvar indexOf = [].indexOf ?\n    function (arr, item) {\n        return arr.indexOf(item)\n    } :\n    function indexOf(arr, item) {\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] === item) {\n                return i\n            }\n        }\n\n        return -1\n    }\n\nfunction unique(arr) {\n    var ret = []\n\n    for (var i = 0; i < arr.length; i++) {\n        var item = arr[i]\n        if (indexOf(ret, item) === -1) {\n            ret.push(item)\n        }\n    }\n\n    return ret\n}\n```\n# 方法三\n优化方法二：写2个函数方法表示很繁琐，可以使用使用对象属性来判断\n缺点：相同的字符串类型数值和数字类型的数值不会去重\n```\nfunction unique(arr) {\n    var ret = [];\n    var hash = {};\n\n    for (var i = 0; i < arr.length; i++) {\n        var item = arr[i];\n        var key = typeof (item) + item;\n        if (hash[key] !== 1) {\n            ret.push(item);\n            hash[key] = 1;\n        }\n    }\n\n    return ret;\n}\n```\n# 方法四\n优化：简单，简洁快捷\n缺点1：兼容低版本浏览器差\n缺点2：相同的字符串类型数值和数字类型的数值不会去重\n```\nfunction unique(arr) {\n    return [...new Set(arr)];\n}\n```\n# 方法五\n优点：兼容性好\n优化点：相同的字符串类型数值和数字类型的数值会去重\n```\nfunction unique(arr) {\n    let ret = [];\n    let obj = {};\n    for (var i = 0; i < arr.length; i++) {\n        let item = arr[i];\n        if (!obj[item]) {\n            ret.push(item);\n            obj[item] = 1;\n        }\n    }\n\n    return ret;\n}\n```\n# 思考\nJS去重的方法有非常多种，以上的5种仅是代表不同的差异。我觉得需要结合实际项目需求开发，根据需求来选择哪种去重方法，根据需求来修改某些条件，或者增加条件，适合需求的才是最好的去重方法。\n\n最简单的，我不用适配低版本浏览器，也不考虑严格的数据类型值，直接用 …new Set(arr) 最快啦~", "article_html" : "<h1 id=\"方法一\">方法一</h1>\n<p>优点：简单，性能好\n缺点1：在IE6-8下数组的indexOf方法不存在\n缺点2：相同的字符串类型数值和数字类型的数值不会去重</p>\n<pre><code>function unique(arr) {\n    var ret = [];\n\n    for (var i = 0; i &lt; arr.length; i++) {\n        var item = arr[i];\n        if (ret.indexOf(item) === -1) {\n            ret.push(item);\n        }\n    }\n\n    return ret;\n}</code></pre><h1 id=\"方法二\">方法二</h1>\n<p>优化方法一：在IE6-8下数组的indexOf方法不存在时，手动添加indexOf实现方法\n缺点2：相同的字符串类型数值和数字类型的数值不会去重</p>\n<pre><code>var indexOf = [].indexOf ?\n    function (arr, item) {\n        return arr.indexOf(item)\n    } :\n    function indexOf(arr, item) {\n        for (var i = 0; i &lt; arr.length; i++) {\n            if (arr[i] === item) {\n                return i\n            }\n        }\n\n        return -1\n    }\n\nfunction unique(arr) {\n    var ret = []\n\n    for (var i = 0; i &lt; arr.length; i++) {\n        var item = arr[i]\n        if (indexOf(ret, item) === -1) {\n            ret.push(item)\n        }\n    }\n\n    return ret\n}</code></pre><h1 id=\"方法三\">方法三</h1>\n<p>优化方法二：写2个函数方法表示很繁琐，可以使用使用对象属性来判断\n缺点：相同的字符串类型数值和数字类型的数值不会去重</p>\n<pre><code>function unique(arr) {\n    var ret = [];\n    var hash = {};\n\n    for (var i = 0; i &lt; arr.length; i++) {\n        var item = arr[i];\n        var key = typeof (item) + item;\n        if (hash[key] !== 1) {\n            ret.push(item);\n            hash[key] = 1;\n        }\n    }\n\n    return ret;\n}</code></pre><h1 id=\"方法四\">方法四</h1>\n<p>优化：简单，简洁快捷\n缺点1：兼容低版本浏览器差\n缺点2：相同的字符串类型数值和数字类型的数值不会去重</p>\n<pre><code>function unique(arr) {\n    return [...new Set(arr)];\n}</code></pre><h1 id=\"方法五\">方法五</h1>\n<p>优点：兼容性好\n优化点：相同的字符串类型数值和数字类型的数值会去重</p>\n<pre><code>function unique(arr) {\n    let ret = [];\n    let obj = {};\n    for (var i = 0; i &lt; arr.length; i++) {\n        let item = arr[i];\n        if (!obj[item]) {\n            ret.push(item);\n            obj[item] = 1;\n        }\n    }\n\n    return ret;\n}</code></pre><h1 id=\"思考\">思考</h1>\n<p>JS去重的方法有非常多种，以上的5种仅是代表不同的差异。我觉得需要结合实际项目需求开发，根据需求来选择哪种去重方法，根据需求来修改某些条件，或者增加条件，适合需求的才是最好的去重方法。</p>\n<p>最简单的，我不用适配低版本浏览器，也不考虑严格的数据类型值，直接用 …new Set(arr) 最快啦~</p>\n", "createdAt" : { "$date" : "2019-10-01T14:10:25.579+0000" }, "updatedAt" : { "$date" : "2019-10-09T14:10:12.423+0000" }, "__v" : 0, "intro" : "JS去重的方法有非常多种。我觉得需要结合实际项目需求开发，根据需求来选择哪种去重方法，根据需求来修改某些条件，或者增加条件，适合需求的才是最好的去重方法。" }
{ "_id" : { "$oid" : "5d9a053bd9e86028888081ff" }, "title_page_img" : "titlepimg/title_page_img_08.jpg", "views" : 6, "commentnum" : 0, "title" : "什么是HTML语义化标签？常见HTML语义化标签大全", "author" : "易刺猬", "label" : { "$oid" : "5d9201466d6c3958a0c5add1" }, "article" : "## 一、什么是HTML语义化标签\n语义化的标签，旨在让标签有自己的含义。\n```\n<p>一行文字</p>\n<span>一行文字</span>\n```\n1\n2\n如上代码，p 标签与 span 标签都区别之一就是，p 标签的含义是：段落。而 span 标签责没有独特的含义。\n\n## 二、语义化标签的优势\n代码结构清晰，方便阅读，有利于团队合作开发。\n方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。\n有利于搜索引擎优化（SEO）。\n三、常见的语义化标签\n因此我们在写页面结构时，应尽量使用有 语义的HTML 标签\n```\n<title>：页面主体内容。\n<hn>：h1~h6，分级标题，<h1> 与 <title> 协调有利于搜索引擎优化。\n<ul>：无序列表。\n<li>：有序列表。\n<header>：页眉通常包括网站标志、主导航、全站链接以及搜索框。\n<nav>：标记导航，仅对文档中重要的链接群使用。\n<main>：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。\n<article>：定义外部的内容，其中的内容独立于文档的其余部分。\n<section>：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。\n<aside>：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。\n<footer>：页脚，只有当父级是body时，才是整个页面的页脚。\n<small>：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。\n<strong>：和 em 标签一样，用于强调文本，但它强调的程度更强一些。\n<em>：将其中的文本表示为强调的内容，表现为斜体。\n<mark>：使用黄色突出显示部分文本。\n<figure>：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。\n<figcaption>：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。\n<cite>：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。\n<blockquoto>：定义块引用，块引用拥有它们自己的空间。\n<q>：短的引述（跨浏览器问题，尽量避免使用）。\n<time>：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。\n<abbr>：简称或缩写。\n<dfn>：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。\n<address>：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。\n<del>：移除的内容。\n<ins>：添加的内容。\n<code>：标记代码。\n<meter>：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）\n<progress>：定义运行中的进度（进程）。\n```\n————————————————\n版权声明：本文为CSDN博主「易刺猬」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/eeeecw/article/details/80591511", "article_html" : "<h2 id=\"一、什么是html语义化标签\">一、什么是HTML语义化标签</h2>\n<p>语义化的标签，旨在让标签有自己的含义。</p>\n<pre><code>&lt;p&gt;一行文字&lt;/p&gt;\n&lt;span&gt;一行文字&lt;/span&gt;</code></pre><p>1\n2\n如上代码，p 标签与 span 标签都区别之一就是，p 标签的含义是：段落。而 span 标签责没有独特的含义。</p>\n<h2 id=\"二、语义化标签的优势\">二、语义化标签的优势</h2>\n<p>代码结构清晰，方便阅读，有利于团队合作开发。\n方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。\n有利于搜索引擎优化（SEO）。\n三、常见的语义化标签\n因此我们在写页面结构时，应尽量使用有 语义的HTML 标签</p>\n<pre><code>&lt;title&gt;：页面主体内容。\n&lt;hn&gt;：h1~h6，分级标题，&lt;h1&gt; 与 &lt;title&gt; 协调有利于搜索引擎优化。\n&lt;ul&gt;：无序列表。\n&lt;li&gt;：有序列表。\n&lt;header&gt;：页眉通常包括网站标志、主导航、全站链接以及搜索框。\n&lt;nav&gt;：标记导航，仅对文档中重要的链接群使用。\n&lt;main&gt;：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。\n&lt;article&gt;：定义外部的内容，其中的内容独立于文档的其余部分。\n&lt;section&gt;：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。\n&lt;aside&gt;：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。\n&lt;footer&gt;：页脚，只有当父级是body时，才是整个页面的页脚。\n&lt;small&gt;：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。\n&lt;strong&gt;：和 em 标签一样，用于强调文本，但它强调的程度更强一些。\n&lt;em&gt;：将其中的文本表示为强调的内容，表现为斜体。\n&lt;mark&gt;：使用黄色突出显示部分文本。\n&lt;figure&gt;：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。\n&lt;figcaption&gt;：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。\n&lt;cite&gt;：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。\n&lt;blockquoto&gt;：定义块引用，块引用拥有它们自己的空间。\n&lt;q&gt;：短的引述（跨浏览器问题，尽量避免使用）。\n&lt;time&gt;：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。\n&lt;abbr&gt;：简称或缩写。\n&lt;dfn&gt;：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。\n&lt;address&gt;：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。\n&lt;del&gt;：移除的内容。\n&lt;ins&gt;：添加的内容。\n&lt;code&gt;：标记代码。\n&lt;meter&gt;：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）\n&lt;progress&gt;：定义运行中的进度（进程）。</code></pre><p>————————————————\n版权声明：本文为CSDN博主「易刺猬」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：<a href=\"https://blog.csdn.net/eeeecw/article/details/80591511\">https://blog.csdn.net/eeeecw/article/details/80591511</a></p>\n", "createdAt" : { "$date" : "2019-10-06T15:16:11.196+0000" }, "updatedAt" : { "$date" : "2019-10-11T16:27:44.271+0000" }, "__v" : 0, "intro" : "代码结构清晰，方便阅读，有利于团队合作开发。方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。有利于搜索引擎优化（SEO）。三、常见的语义化标签，因此我们在写页面结构时，应尽量使用有 语义的HTML 标签" }
{ "_id" : { "$oid" : "5d9a0618d9e8602888808200" }, "title_page_img" : "titlepimg/title_page_img_09.jpg", "views" : 8, "commentnum" : 0, "title" : "HTTP状态码大全", "author" : "Mrxh", "label" : { "$oid" : "5d9201466d6c3958a0c5add6" }, "article" : "100-199 用于指定客户端应相应的某些动作。 \n200-299 用于表示请求成功。 \n300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 \n400-499 用于指出客户端的错误。 \n500-599 用于支持服务器错误。 \n\nHttpServletResponse中的常量代表关联不同标准消息的状态码。在servlet程序中，你会更多地用到这些常量的标识来使用状态码。例如：你一般会使用response.setStatus(response.SC_NO_CONTENT)而不是 response.setStatus(204)，因为后者不易理解而且容易导致错误。但是，你应当注意到服务器允许对消息轻微的改变，而客户端只注意状态码的数字值。所以服务器可能只返回 HTTP/1.1 200 而不是 HTTP/1.1 200 OK。 \n\n100 (Continue/继续)\n如果服务器收到头信息中带有100-continue的请求，这是指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100(SC_CONTINUE)允许客户端继续或用417 (Expectation Failed)告诉客户端不同意接受附件。这个状态码是 HTTP 1.1中新加入的。 \n\n101 (Switching Protocols/转换协议)\n101 (SC_SWITCHING_PROTOCOLS)状态码是指服务器将按照其上的头信息变为一个不同的协议。这是 HTTP 1.1中新加入的。 \n\n200 (OK/正常)\n200 (SC_OK)的意思是一切正常。一般用于相应GET和POST请求。这个状态码对servlet是缺省的；如果没有调用setStatus方法的话，就会得到200。 \n\n201 (Created/已创建)\n201 (SC_CREATED)表示服务器在请求的响应中建立了新文档；应在定位头信息中给出它的URL。\n\n202 (Accepted/接受)\n202 (SC_ACCEPTED)告诉客户端请求正在被执行，但还没有处理完。 \n\n203 (Non-Authoritative Information/非官方信息)\n状态码203 (SC_NON_AUTHORITATIVE_INFORMATION)是表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。这是 HTTP 1.1中新加入的。 \n\n204 (No Content/无内容)\n在并没有新文档的情况下，204 (SC_NO_CONTENT)确保浏览器继续显示先前的文档。这各状态码对于用户周期性的重载某一页非常有用，并且你可以确定先前的页面是否已经更新。例如，某个servlet可能作如下操作： \nint pageVersion =Integer.parseInt(request.getParameter(\"pageVersion\"));\nif (pageVersion >;= currentVersion) {\n   response.setStatus(response.SC_NO_CONTENT);\n} else {\n       // Create regular page\n}\n但是，这种方法对通过刷新响应头信息或等价的HTML标记自动重载的页面起作用，因为它会返回一个204状态码停止以后的重载。但基于JavaScript脚本的自动重载在这种情况下仍然需要能够起作用。可以阅读本书7.2 ( HTTP 1.1 Response Headers and Their Meaning/HTTP 1.1响应头信息以及他们的意义)部分的详细讨论。 \n\n205 (Reset Content/重置内容)\n重置内容205 (SC_RESET_CONTENT)的意思是虽然没有新文档但浏览器要重置文档显示。这个状态码用于强迫浏览器清除表单域。这是 HTTP 1.1中新加入的。 \n\n206 (Partial Content/局部内容)\n206 (SC_PARTIAL_CONTENT)是在服务器完成了一个包含Range头信息的局部请求时被发送的。这是 HTTP 1.1中新加入的。 \n\n300 (Multiple Choices/多重选择)\n300 (SC_MULTIPLE_CHOICES)表示被请求的文档可以在多个地方找到，并将在返回的文档中列出来。如果服务器有首选设置，首选项将会被列于定位响应头信息中。 \n\n301 (Moved Permanently)\n301 (SC_MOVED_PERMANENTLY)状态是指所请求的文档在别的地方；文档新的URL会在定位响应头信息中给出。浏览器会自动连接到新的URL。 \n\n302 (Found/找到)\n与301有些类似，只是定位头信息中所给的URL应被理解为临时交换地址而不是永久的。注意：在 HTTP 1.0中，消息是临时移动(Moved Temporarily)的而不是被找到，因此HttpServletResponse中的常量是SC_MOVED_TEMPORARILY不是我们以为的SC_FOUND。 \n\n注意\n代表状态码302的常量是SC_MOVED_TEMPORARILY而不是SC_FOUND。 \n\n状态码302是非常有用的因为浏览器自动连接在定为响应头信息中给出的新URL。这非常有用，而且为此有一个专门的方法——sendRedirect。使用response.sendRedirect(url)比调用response.setStatus(response.SC_MOVED_TEMPORARILY)和response.setHeader(\"Location\", url)多几个好处。首先，response.sendRedirect(url)方法明显要简单和容易。第二，servlet自动建立一页保存这一连接以提供给那些不能自动转向的浏览器显示。最后，在servlet 2.2版本（J2EE中的版本）中，sendRedirect能够处理相对路径，自动转换为绝对路径。但是你只能在2.1版本中使用绝对路径。 \n\n如果你将用户转向到站点的另一页中，你要用 HttpServletResponse 中的 encodeURL 方法传送URL。这么做可预防不断使用基于URL重写的会话跟踪的情况。URL重写是一种在你的网站跟踪不使用 cookies 的用户的方法。这是通过在每一个URL尾部附加路径信息实现的，但是 servlet 会话跟踪API会自动的注意这些细节。会话跟踪在第九章讨论，并且养成使用 encodeURL 的习惯会使以后添加会话跟踪的功能更容易很多。 \n\n核心技巧\n如果你将用户转向到你的站点的其他页面，用 response.sendRedirect(response.encodeURL(url)) 的方式事先计划好会话跟踪(session tracking)要比只是调用 response.sendRedirect(url) 好的多。 \n\n这个状态码有时可以与301交换使用。例如，如果你错误的访问了http://www.talentdigger.cn/home/link.php?url=aG9zdC9%2BdXNlcg%3D%3D（路径信息不完整），有些服务器就会回复301状态码而有些则回复302。从技术上说，如果最初的请求是GET浏览器只是被假定自动转向。如果想了解更多细节，请看状态码307的讨论。 \n\n303 (See Other/参见其他信息)\n这个状态码和 301、302 相似，只是如果最初的请求是 POST，那么新文档（在定位头信息中给出）药用 GET 找回。这个状态码是新加入 HTTP 1.1中的。 \n\n304 (Not Modified/为修正)\n当客户端有一个缓存的文档，通过提供一个 If-Modified-Since 头信息可指出客户端只希望文档在指定日期之后有所修改时才会重载此文档，用这种方式可以进行有条件的请求。304 (SC_NOT_MODIFIED)是指缓冲的版本已经被更新并且客户端应刷新文档。另外，服务器将返回请求的文档及状态码 200。servlet一般情况下不会直接设置这个状态码。它们会实现getLastModified方法并根据修正日期让默认服务方法处理有条件的请求。这个方法的例程已在2.8部分(An Example Using Servlet Initialization and Page Modification Dates/一个使用servlet初始化和页面修正日期的例子)给出。 \n\n305 (Use Proxy/使用代理)\n305 (SC_USE_PROXY)表示所请求的文档要通过定位头信息中的代理服务器获得。这个状态码是新加入 HTTP 1.1中的。 \n\n307 (Temporary Redirect/临时重定向)\n浏览器处理307状态的规则与302相同。307状态被加入到 HTTP 1.1中是由于许多浏览器在收到302响应时即使是原始消息为POST的情况下仍然执行了错误的转向。只有在收到303响应时才假定浏览器会在POST请求时重定向。添加这个新的状态码的目的很明确：在响应为303时按照GET和POST请求转向；而在307响应时则按照GET请求转向而不是POST请求。注意：由于某些原因在HttpServletResponse中还没有与这个状态对应的常量。该状态码是新加入HTTP 1.1中的。 \n\n注意\n在 HttpServletResponse 中没有 SC_TEMPORARY_REDIRECT 常量，所以你只能显示的使用307状态码。 \n\n400 (Bad Request/错误请求)\n400 (SC_BAD_REQUEST)指出客户端请求中的语法错误。 \n\n401 (Unauthorized/未授权)\n401 (SC_UNAUTHORIZED)表示客户端在授权头信息中没有有效的身份信息时访问受到密码保护的页面。这个响应必须包含一个WWW-Authenticate的授权信息头。例如，在本书4.5部分中的“Restricting Access to Web Pages./限制访问Web页。” \n\n403 (Forbidden/禁止)\n403 (SC_FORBIDDEN)的意思是除非拥有授权否则服务器拒绝提供所请求的资源。这个状态经常会由于服务器上的损坏文件或目录许可而引起。 \n\n404 (Not Found/未找到)\n404 (SC_NOT_FOUND)状态每个网络程序员可能都遇到过，他告诉客户端所给的地址无法找到任何资源。它是表示“没有所访问页面”的标准方式。这个状态码是常用的响应并且在HttpServletResponse类中有专门的方法实现它：sendError(\"message\")。相对于setStatus使用sendError得好处是：服务器会自动生成一个错误页来显示错误信息。但是，Internet Explorer 5浏览器却默认忽略你发挥的错误页面并显示其自定义的错误提示页面，虽然微软这么做违反了 HTTP 规范。要关闭此功能，在工具菜单里，选择Internet选项，进入高级标签页，并确认“显示友好的 HTTP 错误信息”选项（在我的浏览器中是倒数第8各选项）没有被选。但是很少有用户知道此选项，因此这个特性被IE5隐藏了起来使用户无法看到你所返回给用户的信息。而其他主流浏览器及IE4都完全的显示服务器生成的错误提示页面。可以参考图6-3及6-4中的例子。 \n\n核心警告\n默认情况下，IE5忽略服务端生成的错误提示页面。 \n\n405 (Method Not Allowed/方法未允许)\n405 (SC_METHOD_NOT_ALLOWED)指出请求方法(GET, POST, HEAD, PUT, DELETE, 等)对某些特定的资源不允许使用。该状态码是新加入 HTTP 1.1中的。 \n\n406 (Not Acceptable/无法访问)\n406 (SC_NOT_ACCEPTABLE)表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。见本书7.2部分中的表7.1(HTTP 1.1 Response Headers and Their Meaning/HTTP 1.1响应头信息以及他们的意义)中对MIME类型的介绍。406是新加入 HTTP 1.1中的。 \n\n407 (Proxy Authentication Required/代理服务器认证要求)\n407 (SC_PROXY_AUTHENTICATION_REQUIRED)与401状态有些相似，只是这个状态用于代理服务器。该状态指出客户端必须通过代理服务器的认证。代理服务器返回一个Proxy-Authenticate响应头信息给客户端，这会引起客户端使用带有Proxy-Authorization请求的头信息重新连接。该状态码是新加入 HTTP 1.1中的。 \n\n408 (Request Timeout/请求超时)\n408 (SC_REQUEST_TIMEOUT)是指服务端等待客户端发送请求的时间过长。该状态码是新加入 HTTP 1.1中的。 \n\n409 (Conflict/冲突)\n该状态通常与PUT请求一同使用，409 (SC_CONFLICT)状态常被用于试图上传版本不正确的文件时。该状态码是新加入 HTTP 1.1中的。 \n\n410 (Gone/已经不存在)\n410 (SC_GONE)告诉客户端所请求的文档已经不存在并且没有更新的地址。410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。该状态码是新加入 HTTP 1.1中的。 \n\n411 (Length Required/需要数据长度)\n411 (SC_LENGTH_REQUIRED)表示服务器不能处理请求（假设为带有附件的POST请求），除非客户端发送Content-Length头信息指出发送给服务器的数据的大小。该状态是新加入 HTTP 1.1的。 \n\n412 (Precondition Failed/先决条件错误)\n412 (SC_PRECONDITION_FAILED)状态指出请求头信息中的某些先决条件是错误的。该状态是新加入 HTTP 1.1的。 \n\n413 (Request Entity Too Large/请求实体过大)\n413 (SC_REQUEST_ENTITY_TOO_LARGE)告诉客户端现在所请求的文档比服务器现在想要处理的要大。如果服务器认为能够过一段时间处理，则会包含一个Retry-After的响应头信息。该状态是新加入 HTTP 1.1的。 \n\n414 (Request URI Too Long/请求URI过长)\n414 (SC_REQUEST_URI_TOO_LONG)状态用于在URI过长的情况时。这里所指的“URI”是指URL中主机、域名及端口号之后的内容。例如：在URL--http://www.y2k-disaster.com:8080/we/look/silly/now/中URI是指/we/look/silly/now/。该状态是新加入 HTTP 1.1的。 \n\n415 (Unsupported Media Type/不支持的媒体格式)\n415 (SC_UNSUPPORTED_MEDIA_TYPE)意味着请求所带的附件的格式类型服务器不知道如何处理。该状态是新加入 HTTP 1.1的。 \n\n416 (Requested Range Not Satisfiable/请求范围无法满足)\n416表示客户端包含了一个服务器无法满足的Range头信息的请求。该状态是新加入 HTTP 1.1的。奇怪的是，在servlet 2.1版本API的HttpServletResponse中并没有相应的常量代表该状态。 \n\n注意\n在servlet 2.1的规范中，类HttpServletResponse并没有SC_REQUESTED_RANGE_NOT_SATISFIABLE 这样的常量，所以你只能直接使用416。在servlet 2.2版本之后都包含了此常量。 \n\n417 (Expectation Failed/期望失败)\n如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100 (SC_CONTINUE)状态告诉客户端可以继续发送附件。该状态是新加入 HTTP 1.1的。 \n\n500 (Internal Server Error/内部服务器错误)\n500 (SC_INTERNAL_SERVER_ERROR) 是常用的“服务器错误”状态。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。 \n\n501 (Not Implemented/未实现)\n501 (SC_NOT_IMPLEMENTED)状态告诉客户端服务器不支持请求中要求的功能。例如，客户端执行了如PUT这样的服务器并不支持的命令。 \n\n502 (Bad Gateway/错误的网关)\n502 (SC_BAD_GATEWAY)被用于充当代理或网关的服务器；该状态指出接收服务器接收到远端服务器的错误响应。 \n\n503 (Service Unavailable/服务无法获得)\n状态码503 (SC_SERVICE_UNAVAILABLE)表示服务器由于在维护或已经超载而无法响应。例如，如果某些线程或数据库连接池已经没有空闲则servlet会返回这个头信息。服务器可提供一个Retry-After头信息告诉客户端什么时候可以在试一次。 \n\n504 (Gateway Timeout/网关超时)\n该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。该状态是新加入 HTTP 1.1的。 \n\n505 (HTTP Version Not Supported/不支持的 HTTP 版本)\n505 (SC_HTTP_VERSION_NOT_SUPPORTED)状态码是说服务器并不支持在请求中所标明 HTTP 版本。该状态是新加入 HTTP 1.1的。", "article_html" : "<p>100-199 用于指定客户端应相应的某些动作。 \n200-299 用于表示请求成功。 \n300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 \n400-499 用于指出客户端的错误。 \n500-599 用于支持服务器错误。 </p>\n<p>HttpServletResponse中的常量代表关联不同标准消息的状态码。在servlet程序中，你会更多地用到这些常量的标识来使用状态码。例如：你一般会使用response.setStatus(response.SC_NO_CONTENT)而不是 response.setStatus(204)，因为后者不易理解而且容易导致错误。但是，你应当注意到服务器允许对消息轻微的改变，而客户端只注意状态码的数字值。所以服务器可能只返回 HTTP/1.1 200 而不是 HTTP/1.1 200 OK。 </p>\n<p>100 (Continue/继续)\n如果服务器收到头信息中带有100-continue的请求，这是指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100(SC_CONTINUE)允许客户端继续或用417 (Expectation Failed)告诉客户端不同意接受附件。这个状态码是 HTTP 1.1中新加入的。 </p>\n<p>101 (Switching Protocols/转换协议)\n101 (SC_SWITCHING_PROTOCOLS)状态码是指服务器将按照其上的头信息变为一个不同的协议。这是 HTTP 1.1中新加入的。 </p>\n<p>200 (OK/正常)\n200 (SC_OK)的意思是一切正常。一般用于相应GET和POST请求。这个状态码对servlet是缺省的；如果没有调用setStatus方法的话，就会得到200。 </p>\n<p>201 (Created/已创建)\n201 (SC_CREATED)表示服务器在请求的响应中建立了新文档；应在定位头信息中给出它的URL。</p>\n<p>202 (Accepted/接受)\n202 (SC_ACCEPTED)告诉客户端请求正在被执行，但还没有处理完。 </p>\n<p>203 (Non-Authoritative Information/非官方信息)\n状态码203 (SC_NON_AUTHORITATIVE_INFORMATION)是表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。这是 HTTP 1.1中新加入的。 </p>\n<p>204 (No Content/无内容)\n在并没有新文档的情况下，204 (SC_NO_CONTENT)确保浏览器继续显示先前的文档。这各状态码对于用户周期性的重载某一页非常有用，并且你可以确定先前的页面是否已经更新。例如，某个servlet可能作如下操作： \nint pageVersion =Integer.parseInt(request.getParameter(&quot;pageVersion&quot;));\nif (pageVersion &gt;;= currentVersion) {\n   response.setStatus(response.SC_NO_CONTENT);\n} else {\n       // Create regular page\n}\n但是，这种方法对通过刷新响应头信息或等价的HTML标记自动重载的页面起作用，因为它会返回一个204状态码停止以后的重载。但基于JavaScript脚本的自动重载在这种情况下仍然需要能够起作用。可以阅读本书7.2 ( HTTP 1.1 Response Headers and Their Meaning/HTTP 1.1响应头信息以及他们的意义)部分的详细讨论。 </p>\n<p>205 (Reset Content/重置内容)\n重置内容205 (SC_RESET_CONTENT)的意思是虽然没有新文档但浏览器要重置文档显示。这个状态码用于强迫浏览器清除表单域。这是 HTTP 1.1中新加入的。 </p>\n<p>206 (Partial Content/局部内容)\n206 (SC_PARTIAL_CONTENT)是在服务器完成了一个包含Range头信息的局部请求时被发送的。这是 HTTP 1.1中新加入的。 </p>\n<p>300 (Multiple Choices/多重选择)\n300 (SC_MULTIPLE_CHOICES)表示被请求的文档可以在多个地方找到，并将在返回的文档中列出来。如果服务器有首选设置，首选项将会被列于定位响应头信息中。 </p>\n<p>301 (Moved Permanently)\n301 (SC_MOVED_PERMANENTLY)状态是指所请求的文档在别的地方；文档新的URL会在定位响应头信息中给出。浏览器会自动连接到新的URL。 </p>\n<p>302 (Found/找到)\n与301有些类似，只是定位头信息中所给的URL应被理解为临时交换地址而不是永久的。注意：在 HTTP 1.0中，消息是临时移动(Moved Temporarily)的而不是被找到，因此HttpServletResponse中的常量是SC_MOVED_TEMPORARILY不是我们以为的SC_FOUND。 </p>\n<p>注意\n代表状态码302的常量是SC_MOVED_TEMPORARILY而不是SC_FOUND。 </p>\n<p>状态码302是非常有用的因为浏览器自动连接在定为响应头信息中给出的新URL。这非常有用，而且为此有一个专门的方法——sendRedirect。使用response.sendRedirect(url)比调用response.setStatus(response.SC_MOVED_TEMPORARILY)和response.setHeader(&quot;Location&quot;, url)多几个好处。首先，response.sendRedirect(url)方法明显要简单和容易。第二，servlet自动建立一页保存这一连接以提供给那些不能自动转向的浏览器显示。最后，在servlet 2.2版本（J2EE中的版本）中，sendRedirect能够处理相对路径，自动转换为绝对路径。但是你只能在2.1版本中使用绝对路径。 </p>\n<p>如果你将用户转向到站点的另一页中，你要用 HttpServletResponse 中的 encodeURL 方法传送URL。这么做可预防不断使用基于URL重写的会话跟踪的情况。URL重写是一种在你的网站跟踪不使用 cookies 的用户的方法。这是通过在每一个URL尾部附加路径信息实现的，但是 servlet 会话跟踪API会自动的注意这些细节。会话跟踪在第九章讨论，并且养成使用 encodeURL 的习惯会使以后添加会话跟踪的功能更容易很多。 </p>\n<p>核心技巧\n如果你将用户转向到你的站点的其他页面，用 response.sendRedirect(response.encodeURL(url)) 的方式事先计划好会话跟踪(session tracking)要比只是调用 response.sendRedirect(url) 好的多。 </p>\n<p>这个状态码有时可以与301交换使用。例如，如果你错误的访问了<a href=\"http://www.talentdigger.cn/home/link.php?url=aG9zdC9%2BdXNlcg%3D%3D%EF%BC%88%E8%B7%AF%E5%BE%84%E4%BF%A1%E6%81%AF%E4%B8%8D%E5%AE%8C%E6%95%B4%EF%BC%89%EF%BC%8C%E6%9C%89%E4%BA%9B%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B0%B1%E4%BC%9A%E5%9B%9E%E5%A4%8D301%E7%8A%B6%E6%80%81%E7%A0%81%E8%80%8C%E6%9C%89%E4%BA%9B%E5%88%99%E5%9B%9E%E5%A4%8D302%E3%80%82%E4%BB%8E%E6%8A%80%E6%9C%AF%E4%B8%8A%E8%AF%B4%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%80%E5%88%9D%E7%9A%84%E8%AF%B7%E6%B1%82%E6%98%AFGET%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%AA%E6%98%AF%E8%A2%AB%E5%81%87%E5%AE%9A%E8%87%AA%E5%8A%A8%E8%BD%AC%E5%90%91%E3%80%82%E5%A6%82%E6%9E%9C%E6%83%B3%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E7%BB%86%E8%8A%82%EF%BC%8C%E8%AF%B7%E7%9C%8B%E7%8A%B6%E6%80%81%E7%A0%81307%E7%9A%84%E8%AE%A8%E8%AE%BA%E3%80%82\">http://www.talentdigger.cn/home/link.php?url=aG9zdC9%2BdXNlcg%3D%3D（路径信息不完整），有些服务器就会回复301状态码而有些则回复302。从技术上说，如果最初的请求是GET浏览器只是被假定自动转向。如果想了解更多细节，请看状态码307的讨论。</a> </p>\n<p>303 (See Other/参见其他信息)\n这个状态码和 301、302 相似，只是如果最初的请求是 POST，那么新文档（在定位头信息中给出）药用 GET 找回。这个状态码是新加入 HTTP 1.1中的。 </p>\n<p>304 (Not Modified/为修正)\n当客户端有一个缓存的文档，通过提供一个 If-Modified-Since 头信息可指出客户端只希望文档在指定日期之后有所修改时才会重载此文档，用这种方式可以进行有条件的请求。304 (SC_NOT_MODIFIED)是指缓冲的版本已经被更新并且客户端应刷新文档。另外，服务器将返回请求的文档及状态码 200。servlet一般情况下不会直接设置这个状态码。它们会实现getLastModified方法并根据修正日期让默认服务方法处理有条件的请求。这个方法的例程已在2.8部分(An Example Using Servlet Initialization and Page Modification Dates/一个使用servlet初始化和页面修正日期的例子)给出。 </p>\n<p>305 (Use Proxy/使用代理)\n305 (SC_USE_PROXY)表示所请求的文档要通过定位头信息中的代理服务器获得。这个状态码是新加入 HTTP 1.1中的。 </p>\n<p>307 (Temporary Redirect/临时重定向)\n浏览器处理307状态的规则与302相同。307状态被加入到 HTTP 1.1中是由于许多浏览器在收到302响应时即使是原始消息为POST的情况下仍然执行了错误的转向。只有在收到303响应时才假定浏览器会在POST请求时重定向。添加这个新的状态码的目的很明确：在响应为303时按照GET和POST请求转向；而在307响应时则按照GET请求转向而不是POST请求。注意：由于某些原因在HttpServletResponse中还没有与这个状态对应的常量。该状态码是新加入HTTP 1.1中的。 </p>\n<p>注意\n在 HttpServletResponse 中没有 SC_TEMPORARY_REDIRECT 常量，所以你只能显示的使用307状态码。 </p>\n<p>400 (Bad Request/错误请求)\n400 (SC_BAD_REQUEST)指出客户端请求中的语法错误。 </p>\n<p>401 (Unauthorized/未授权)\n401 (SC_UNAUTHORIZED)表示客户端在授权头信息中没有有效的身份信息时访问受到密码保护的页面。这个响应必须包含一个WWW-Authenticate的授权信息头。例如，在本书4.5部分中的“Restricting Access to Web Pages./限制访问Web页。” </p>\n<p>403 (Forbidden/禁止)\n403 (SC_FORBIDDEN)的意思是除非拥有授权否则服务器拒绝提供所请求的资源。这个状态经常会由于服务器上的损坏文件或目录许可而引起。 </p>\n<p>404 (Not Found/未找到)\n404 (SC_NOT_FOUND)状态每个网络程序员可能都遇到过，他告诉客户端所给的地址无法找到任何资源。它是表示“没有所访问页面”的标准方式。这个状态码是常用的响应并且在HttpServletResponse类中有专门的方法实现它：sendError(&quot;message&quot;)。相对于setStatus使用sendError得好处是：服务器会自动生成一个错误页来显示错误信息。但是，Internet Explorer 5浏览器却默认忽略你发挥的错误页面并显示其自定义的错误提示页面，虽然微软这么做违反了 HTTP 规范。要关闭此功能，在工具菜单里，选择Internet选项，进入高级标签页，并确认“显示友好的 HTTP 错误信息”选项（在我的浏览器中是倒数第8各选项）没有被选。但是很少有用户知道此选项，因此这个特性被IE5隐藏了起来使用户无法看到你所返回给用户的信息。而其他主流浏览器及IE4都完全的显示服务器生成的错误提示页面。可以参考图6-3及6-4中的例子。 </p>\n<p>核心警告\n默认情况下，IE5忽略服务端生成的错误提示页面。 </p>\n<p>405 (Method Not Allowed/方法未允许)\n405 (SC_METHOD_NOT_ALLOWED)指出请求方法(GET, POST, HEAD, PUT, DELETE, 等)对某些特定的资源不允许使用。该状态码是新加入 HTTP 1.1中的。 </p>\n<p>406 (Not Acceptable/无法访问)\n406 (SC_NOT_ACCEPTABLE)表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。见本书7.2部分中的表7.1(HTTP 1.1 Response Headers and Their Meaning/HTTP 1.1响应头信息以及他们的意义)中对MIME类型的介绍。406是新加入 HTTP 1.1中的。 </p>\n<p>407 (Proxy Authentication Required/代理服务器认证要求)\n407 (SC_PROXY_AUTHENTICATION_REQUIRED)与401状态有些相似，只是这个状态用于代理服务器。该状态指出客户端必须通过代理服务器的认证。代理服务器返回一个Proxy-Authenticate响应头信息给客户端，这会引起客户端使用带有Proxy-Authorization请求的头信息重新连接。该状态码是新加入 HTTP 1.1中的。 </p>\n<p>408 (Request Timeout/请求超时)\n408 (SC_REQUEST_TIMEOUT)是指服务端等待客户端发送请求的时间过长。该状态码是新加入 HTTP 1.1中的。 </p>\n<p>409 (Conflict/冲突)\n该状态通常与PUT请求一同使用，409 (SC_CONFLICT)状态常被用于试图上传版本不正确的文件时。该状态码是新加入 HTTP 1.1中的。 </p>\n<p>410 (Gone/已经不存在)\n410 (SC_GONE)告诉客户端所请求的文档已经不存在并且没有更新的地址。410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。该状态码是新加入 HTTP 1.1中的。 </p>\n<p>411 (Length Required/需要数据长度)\n411 (SC_LENGTH_REQUIRED)表示服务器不能处理请求（假设为带有附件的POST请求），除非客户端发送Content-Length头信息指出发送给服务器的数据的大小。该状态是新加入 HTTP 1.1的。 </p>\n<p>412 (Precondition Failed/先决条件错误)\n412 (SC_PRECONDITION_FAILED)状态指出请求头信息中的某些先决条件是错误的。该状态是新加入 HTTP 1.1的。 </p>\n<p>413 (Request Entity Too Large/请求实体过大)\n413 (SC_REQUEST_ENTITY_TOO_LARGE)告诉客户端现在所请求的文档比服务器现在想要处理的要大。如果服务器认为能够过一段时间处理，则会包含一个Retry-After的响应头信息。该状态是新加入 HTTP 1.1的。 </p>\n<p>414 (Request URI Too Long/请求URI过长)\n414 (SC_REQUEST_URI_TOO_LONG)状态用于在URI过长的情况时。这里所指的“URI”是指URL中主机、域名及端口号之后的内容。例如：在URL--<a href=\"http://www.y2k-disaster.com:8080/we/look/silly/now/%E4%B8%ADURI%E6%98%AF%E6%8C%87/we/look/silly/now/%E3%80%82%E8%AF%A5%E7%8A%B6%E6%80%81%E6%98%AF%E6%96%B0%E5%8A%A0%E5%85%A5\">http://www.y2k-disaster.com:8080/we/look/silly/now/中URI是指/we/look/silly/now/。该状态是新加入</a> HTTP 1.1的。 </p>\n<p>415 (Unsupported Media Type/不支持的媒体格式)\n415 (SC_UNSUPPORTED_MEDIA_TYPE)意味着请求所带的附件的格式类型服务器不知道如何处理。该状态是新加入 HTTP 1.1的。 </p>\n<p>416 (Requested Range Not Satisfiable/请求范围无法满足)\n416表示客户端包含了一个服务器无法满足的Range头信息的请求。该状态是新加入 HTTP 1.1的。奇怪的是，在servlet 2.1版本API的HttpServletResponse中并没有相应的常量代表该状态。 </p>\n<p>注意\n在servlet 2.1的规范中，类HttpServletResponse并没有SC_REQUESTED_RANGE_NOT_SATISFIABLE 这样的常量，所以你只能直接使用416。在servlet 2.2版本之后都包含了此常量。 </p>\n<p>417 (Expectation Failed/期望失败)\n如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100 (SC_CONTINUE)状态告诉客户端可以继续发送附件。该状态是新加入 HTTP 1.1的。 </p>\n<p>500 (Internal Server Error/内部服务器错误)\n500 (SC_INTERNAL_SERVER_ERROR) 是常用的“服务器错误”状态。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。 </p>\n<p>501 (Not Implemented/未实现)\n501 (SC_NOT_IMPLEMENTED)状态告诉客户端服务器不支持请求中要求的功能。例如，客户端执行了如PUT这样的服务器并不支持的命令。 </p>\n<p>502 (Bad Gateway/错误的网关)\n502 (SC_BAD_GATEWAY)被用于充当代理或网关的服务器；该状态指出接收服务器接收到远端服务器的错误响应。 </p>\n<p>503 (Service Unavailable/服务无法获得)\n状态码503 (SC_SERVICE_UNAVAILABLE)表示服务器由于在维护或已经超载而无法响应。例如，如果某些线程或数据库连接池已经没有空闲则servlet会返回这个头信息。服务器可提供一个Retry-After头信息告诉客户端什么时候可以在试一次。 </p>\n<p>504 (Gateway Timeout/网关超时)\n该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。该状态是新加入 HTTP 1.1的。 </p>\n<p>505 (HTTP Version Not Supported/不支持的 HTTP 版本)\n505 (SC_HTTP_VERSION_NOT_SUPPORTED)状态码是说服务器并不支持在请求中所标明 HTTP 版本。该状态是新加入 HTTP 1.1的。</p>\n", "createdAt" : { "$date" : "2019-10-06T15:19:52.058+0000" }, "updatedAt" : { "$date" : "2019-10-11T16:45:25.478+0000" }, "__v" : 0, "intro" : "100-199 用于指定客户端应相应的某些动作。 200-299 用于表示请求成功。 300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 400-499 用于指出客户端的错误。 500-599 用于支持服务器错误。 HttpServletResponse中的常量代表关联不同标准消息的状态码。在servlet程序中，你会更多地用到这些常量的标识来使用状态码。 \r\n" }
{ "_id" : { "$oid" : "5d9a070dd9e8602888808201" }, "title_page_img" : "titlepimg/title_page_img_10.jpg", "views" : 7, "commentnum" : 0, "title" : "CSS3的新特性整理", "author" : "Mrxh", "label" : { "$oid" : "5d9201466d6c3958a0c5add2" }, "article" : "animation    IE10\n\nanimation的六大属性\n\nanimation-name规定需要绑定选择器的keyframe名称\n\nanimation-duration规定完成动画所花费的时间 s ms \nobject.style.animationDuration=\"3s\"\n\nanimation-timing-function动画的速度曲线\n默认值ease \nobject.style.animationTimingFunction=\"linear\"\n语法 animation-timing-function:value\n\n\nanimation-timing-function使用名为三次Cubic Bezier贝塞尔曲线函数的数学函数，来生成速度曲线 可以使用自己的值也可 \n以预定义的值\n\n值:linear从始到末以相同的速度\nease 默认 从低速 加快在结束前变慢\nease-in动画低速开始\nease-out动画低速结束\nease-in-out动画从低速开始和结束\ncubic-bezier(n,n,n,n)在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值\n\n\nanimation-deplay动画开始之前的延迟\nanimation-delay: time;\nJavaScript 语法：object.style.animationDelay=\"2s\"\nanimation-delay 值以秒或毫秒计。\n允许负值，-2s 使动画马上开始，但跳过 2 秒进入动画\n\n \n\nanimation-iteration-count动画播放的次数 IE10\nanimation-iteration-count: n|infinite\nJavaScript 语法： object.style.animationIterationCount=3\n\n \n\nanimation-direction是否应该轮流反向播放动画\nanimation-direction 值是 \"alternate\"，则动画会在奇数次数（1、3、5 等等）正常播放，而在偶数次数（2、4、6 等等 \n）向后播放\nanimation-direction: normal|alternate;\nJavaScript 语法： object.style.animationDirection=\"alternate\"\n\n\n默认值 none 0 ease 0 1 normal\njavascript的语法 object.style.animation=\"mymove 5s infinite\"\n\n\nTransition   过渡的四大属性 IE10\n\ntransition-property\ntransiont-property属性规定过渡css属性的名称\ntransition-property: none|all|propertyCSS 属性名称列表，列表以逗号分隔;\nJavaScript 语法： object.style.transitionProperty=\"width,height\"\n\n\ntransition-duration 完成过渡效果需要多少秒或毫秒\ntransition-duration: time;\nJavaScript 语法： object.style.transitionDuration=\"5s\"\n\n\ntransition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-\nbezier(n,n,n,n);\nJavaScript 语法： object.style.transitionTimingFunction=\"linear\"\n\n\ntransition-delay \nJavaScript 语法： object.style.transitionDelay=\"2s\"\ntransition-delay: time;\n\n默认值 all 0 ease 0\ntransition:property duration timing-function delay\njavascript语法：object.style.transition=\"width 2s\"\n \n\n \n\ntransform IE10\ntransform 允许我们对元素进行旋转、缩放、移动、或倾斜\n默认none \njavascript的语法 object.style.transform=\"rotate(7deg)\"\ntransform: none|transform-functions;\n\nnone 不进行转换\nmatrix(n,n,n,n,n,n)使用六个值的矩阵\nmatrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)使用 16 个值的 4x4 矩阵\ntranslate(x,y)2D 转换\ntranslate3d(x,y,z)3D 转换\ntranslateX(x)只是用 X 轴的值\ntranslateY(y)只是用Y轴的值\ntranslateZ(z)只是用Z轴的值\nscale(x,y)2D缩放\nscale3d(x,y,z)3D缩放\nscaleX(x),scaleY(y),scaleZ(z)\nrotate(angle) 2D 旋转，在参数中规定角度\nrotate3d(x,y,z,angle)3D 旋转\nrotateX(angle),rotateY(angle),rotateZ(angle)\nskew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换\nskewX(angle) skewY(angle) perspective(n)\n\n \n\n新增的css3的选择器\n\n复制代码\n 1 E:nth-last-child(n) \n 2 E:nth-of-type(n) \n 3 E:nth-last-of-type(n) \n 4 E:last-child \n 5 E:first-of-type \n 6 E:only-child \n 7 E:only-of-type \n 8 E:empty \n 9 E:checked \n10 E:enabled \n11 E:disabled \n12 E::selection \n13 E:not(s)\n14 E::not(.s)\n15 body: nth-child(even), nth-child(odd)/*：此处他们分别代表了表格（tbody）下面的偶数行和奇数行（tr）*/等等......\n复制代码\n \n\n@Font-face 特性\nFont-face 可以用来加载字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体\n\n\nFont-face 客户端字体案例\n<p><font face=\"arial\">arial courier verdana</font></p>\n\n\nFont-face 服务端字体案例\n\n```\n 1 @font-face { \n 2 font-family: BorderWeb; \n 3 src:url(BORDERW0.eot); \n 4 } \n 5 @font-face { \n 6 font-family: Runic; \n 7 src:url(RUNICMT0.eot); \n 8 }\n 9 \n10 .border { FONT-SIZE: 35px; COLOR: black; FONT-FAMILY: \"BorderWeb\" } \n11 .event { FONT-SIZE: 110px; COLOR: black; FONT-FAMILY: \"Runic\" }\n```\n \n\nWord-wrap\n\n设置或检索当当前行超过指定容器的边界时是否断开转行，文字此时已被打散\n\nText-overflow它与 word-wrap 是协同工作\nword-wrap 设置或检索当当前行超过指定容器的边界时是否断开转行，而 text-overflow 则设置或检索当当前行超过指定容 \n器的边界时如何显示\n```\n.clip{text-overflow:clip; overflow:hidden; white-space:nowrap; \n width:200px;background:#ccc;} \n.ellipsis{text-overflow:ellipsis; overflow:hidden; white-space:nowrap; \n width:200px; background:#ccc;}\n<div class=\"clip\"> 不显示省略标记，而是简单的裁切条</div>\n \n <div class=\"ellipsis\"> 当对象内文本溢出时显示省略标记</div>\n ```\n\n文本渲染\n```\n div { \n -webkit-text-fill-color: black; \n -webkit-text-stroke-color: red; \n -webkit-text-stroke-width: 2.75px; \n }\nText-fill-color: 文字内部填充颜色\nText-stroke-color: 文字边界填充颜色\nText-stroke-width: 文字边界宽度\n```\n文本渲染\n```\n div { \n -webkit-text-fill-color: black; \n -webkit-text-stroke-color: red; \n -webkit-text-stroke-width: 2.75px; \n }\n```\nText-fill-color: 文字内部填充颜色\nText-stroke-color: 文字边界填充颜色\nText-stroke-width: 文字边界宽度\n\ngradient 渐变效果\n线性渐变 linear左上（0% 0%）到右上(0% 100%)\n\nbackground-image:-webkit-gradient(linear,0% 0%,100% 0%,form(red),to(balck))\n\nbackground-image:-webkit-gradient(linear,0% 0%,100% 0%,from(#2A8BBE),\ncolor-stop(0.33,#AAD010),color-stop(0.33,#FF7F00),to(#FE280E));\n\n\n径向渐变radial从一个圆到一个圆的渐变\nbackground:-weblit-gradient(radial,50 50,50,50 50,0,form(black),color-stop(0.5,red),to(blue));\n\n\ncss3的阴影shadow和反射reflect\n\nbackground-clip:border-box;背景从border开始显示；\nbackground-clip：padding-box\nbackground-clip：content-box\nbackground-clip:no-clip:no-clicp默认属性等同于border-box\n\n\nbackground-origin 用于确定背景的位置 通常与background-positon联合使用\n\n\nbackground-size来调整背景图片的大小，注意别和 clip 弄混，这个主要用于设定图片本身\n\nbackground-size: contain; 缩小图片以适合元素（维持像素长宽比）\nbackground-size: cover; 扩展元素以填补元素（维持像素长宽比）\nbackground-size: 100px 100px; 缩小图片至指定的大小 .\nbackground-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包\t含元素的尺寸\n\n \n\n\nbackground-break: continuous; 默认值。忽略盒之间的距离（也就是像元\t素没有分成多个盒子，依然是 \n一个整体一\t样）\nbackground-break: bounding-box; 把盒之间的距离计算在内；\nbackground-break: each-box; 为每个盒子单独重绘背景\n\n \n\ncounter()=[counter(name) | counters(name,list-style-type)]{1,}\n\ncounter-reset IE8\n\ncounter-reset 属性设置某个选择器出现次数的计数器的值。默认为 0。\n利用这个属性，计数器可以设置或重置为任何值，可以是正值或负值。如果没有提供 number，则默认为 0。\n注释：如果使用 \"display: none\"，则无法重置计数器。如果使用 \"visibility: hidden\"，则可以重置计数器\n\nJavaScript 语法：\tobject.style.counterReset=\"subsection\"\n\ncounter-reset的值none id number inherit\n\n \n\nattr()=attr(attr-name)插入元素的属性值 IE8\n\n\ncalc() =calc(四则运算) 动态计算长度值 IE9\n需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；\ncalc()函数支持 \"+\", \"-\", \"*\", \"/\" 运算；\ncalc()函数使用标准的数学运算优先级规则；\n\ninitial属于css-wide关键字，这表示所有的属性都可以接受该值 IE11\n\n\nunset 擦除属性声明\n\n颜色值\ncolor color的颜色名称，HEX，RGB，RGBA，HSL，HSLA，transparent,currentColor\n\n\ncurrentColor\n\nresolution分辨率值不允许有负值\n频率单位包括有： dpi, dpcm, dppx\n\n角度值 angle角度值的正常范围应在[0-360deg]内，例如：-10deg与350deg是等价的\n角度单位包括有： deg, grad一个圆共400梯度, rad 一个圆共2π弧度, turn\n90deg = 100grad = 0.25turn ≈ 1.570796326794897rad\n\n\n长度值与单位\n\nch 数字“0”的宽度 ie9\n\nrem 相对长度单位。相对于根元素(即html元素)font-size计算值的倍数\nvw相对于视口的宽度。视口被均分为100单位的vw ie9\nvh 相对于视口的高度。视口被均分为100单位的vh\nvmax 相对于视口的宽度或高度中较大的那个。其中最大的那个被均分为100单位的vmax\nvmin相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin\nq 1/4毫米（quarter-millimeters）。绝对长度单位。\n1in = 2.54cm = 25.4 mm = 101.6q = 72pt = 6pc = 96px\n\n@import@media@font-face@keyframes@supports\n\n\nE:first-letter/E::first-letter\nE:first-line/E::first-line\nE:before/E::before\nE:after/E::after\nE::placeholderE::selection\n\n\nE:not(s)\nE:root\nE:last-child\nE:only-child\nE:nth-child(n)\nE:nth-last-child(n)\nE:first-of-type\nE:last-of-type\nE:only-of-type\nE:nth-of-type(n)\nE:nth-last-of-type(n)\nE:empty\nE:checked\nE:enabled\nE:disabled\nE:target\n\n \n\n属性选择器\nE[att^=\"val\"]选择具有att属性且属性值为以val开头的字符串的E元素\nE[att$=\"val\"]选择具有att属性且属性值为以val结尾的字符串的E元素\nE[att*=\"val\"]选择具有att属性且属性值为包含val的字符串的E元素\n\nE~F\n\n\nCSS3 的盒子模型\n盒子模型为开发者提供了一种非常灵活的布局方式，但是支持这一特性的浏览器并不多，目前只有 webkit 内核的新版本 safari 和 chrome 以及 gecko 内核的新版本 firefox", "article_html" : "<p>animation    IE10</p>\n<p>animation的六大属性</p>\n<p>animation-name规定需要绑定选择器的keyframe名称</p>\n<p>animation-duration规定完成动画所花费的时间 s ms \nobject.style.animationDuration=&quot;3s&quot;</p>\n<p>animation-timing-function动画的速度曲线\n默认值ease \nobject.style.animationTimingFunction=&quot;linear&quot;\n语法 animation-timing-function:value</p>\n<p>animation-timing-function使用名为三次Cubic Bezier贝塞尔曲线函数的数学函数，来生成速度曲线 可以使用自己的值也可 \n以预定义的值</p>\n<p>值:linear从始到末以相同的速度\nease 默认 从低速 加快在结束前变慢\nease-in动画低速开始\nease-out动画低速结束\nease-in-out动画从低速开始和结束\ncubic-bezier(n,n,n,n)在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值</p>\n<p>animation-deplay动画开始之前的延迟\nanimation-delay: time;\nJavaScript 语法：object.style.animationDelay=&quot;2s&quot;\nanimation-delay 值以秒或毫秒计。\n允许负值，-2s 使动画马上开始，但跳过 2 秒进入动画</p>\n<p>animation-iteration-count动画播放的次数 IE10\nanimation-iteration-count: n|infinite\nJavaScript 语法： object.style.animationIterationCount=3</p>\n<p>animation-direction是否应该轮流反向播放动画\nanimation-direction 值是 &quot;alternate&quot;，则动画会在奇数次数（1、3、5 等等）正常播放，而在偶数次数（2、4、6 等等 \n）向后播放\nanimation-direction: normal|alternate;\nJavaScript 语法： object.style.animationDirection=&quot;alternate&quot;</p>\n<p>默认值 none 0 ease 0 1 normal\njavascript的语法 object.style.animation=&quot;mymove 5s infinite&quot;</p>\n<p>Transition   过渡的四大属性 IE10</p>\n<p>transition-property\ntransiont-property属性规定过渡css属性的名称\ntransition-property: none|all|propertyCSS 属性名称列表，列表以逗号分隔;\nJavaScript 语法： object.style.transitionProperty=&quot;width,height&quot;</p>\n<p>transition-duration 完成过渡效果需要多少秒或毫秒\ntransition-duration: time;\nJavaScript 语法： object.style.transitionDuration=&quot;5s&quot;</p>\n<p>transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-\nbezier(n,n,n,n);\nJavaScript 语法： object.style.transitionTimingFunction=&quot;linear&quot;</p>\n<p>transition-delay \nJavaScript 语法： object.style.transitionDelay=&quot;2s&quot;\ntransition-delay: time;</p>\n<p>默认值 all 0 ease 0\ntransition:property duration timing-function delay\njavascript语法：object.style.transition=&quot;width 2s&quot;</p>\n<p>transform IE10\ntransform 允许我们对元素进行旋转、缩放、移动、或倾斜\n默认none \njavascript的语法 object.style.transform=&quot;rotate(7deg)&quot;\ntransform: none|transform-functions;</p>\n<p>none 不进行转换\nmatrix(n,n,n,n,n,n)使用六个值的矩阵\nmatrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)使用 16 个值的 4x4 矩阵\ntranslate(x,y)2D 转换\ntranslate3d(x,y,z)3D 转换\ntranslateX(x)只是用 X 轴的值\ntranslateY(y)只是用Y轴的值\ntranslateZ(z)只是用Z轴的值\nscale(x,y)2D缩放\nscale3d(x,y,z)3D缩放\nscaleX(x),scaleY(y),scaleZ(z)\nrotate(angle) 2D 旋转，在参数中规定角度\nrotate3d(x,y,z,angle)3D 旋转\nrotateX(angle),rotateY(angle),rotateZ(angle)\nskew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换\nskewX(angle) skewY(angle) perspective(n)</p>\n<p>新增的css3的选择器</p>\n<p>复制代码\n 1 E:nth-last-child(n) \n 2 E:nth-of-type(n) \n 3 E:nth-last-of-type(n) \n 4 E:last-child \n 5 E:first-of-type \n 6 E:only-child \n 7 E:only-of-type \n 8 E:empty \n 9 E:checked \n10 E:enabled \n11 E:disabled \n12 E::selection \n13 E:not(s)\n14 E::not(.s)\n15 body: nth-child(even), nth-child(odd)/<em>：此处他们分别代表了表格（tbody）下面的偶数行和奇数行（tr）</em>/等等......\n复制代码</p>\n<p>@Font-face 特性\nFont-face 可以用来加载字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体</p>\n<p>Font-face 客户端字体案例</p>\n<p><font face=\"arial\">arial courier verdana</font></p>\n\n\n<p>Font-face 服务端字体案例</p>\n<pre><code> 1 @font-face { \n 2 font-family: BorderWeb; \n 3 src:url(BORDERW0.eot); \n 4 } \n 5 @font-face { \n 6 font-family: Runic; \n 7 src:url(RUNICMT0.eot); \n 8 }\n 9 \n10 .border { FONT-SIZE: 35px; COLOR: black; FONT-FAMILY: &quot;BorderWeb&quot; } \n11 .event { FONT-SIZE: 110px; COLOR: black; FONT-FAMILY: &quot;Runic&quot; }</code></pre><p>Word-wrap</p>\n<p>设置或检索当当前行超过指定容器的边界时是否断开转行，文字此时已被打散</p>\n<p>Text-overflow它与 word-wrap 是协同工作\nword-wrap 设置或检索当当前行超过指定容器的边界时是否断开转行，而 text-overflow 则设置或检索当当前行超过指定容 \n器的边界时如何显示</p>\n<pre><code>.clip{text-overflow:clip; overflow:hidden; white-space:nowrap; \n width:200px;background:#ccc;} \n.ellipsis{text-overflow:ellipsis; overflow:hidden; white-space:nowrap; \n width:200px; background:#ccc;}\n&lt;div class=&quot;clip&quot;&gt; 不显示省略标记，而是简单的裁切条&lt;/div&gt;\n\n &lt;div class=&quot;ellipsis&quot;&gt; 当对象内文本溢出时显示省略标记&lt;/div&gt;</code></pre><p>文本渲染</p>\n<pre><code> div { \n -webkit-text-fill-color: black; \n -webkit-text-stroke-color: red; \n -webkit-text-stroke-width: 2.75px; \n }\nText-fill-color: 文字内部填充颜色\nText-stroke-color: 文字边界填充颜色\nText-stroke-width: 文字边界宽度</code></pre><p>文本渲染</p>\n<pre><code> div { \n -webkit-text-fill-color: black; \n -webkit-text-stroke-color: red; \n -webkit-text-stroke-width: 2.75px; \n }</code></pre><p>Text-fill-color: 文字内部填充颜色\nText-stroke-color: 文字边界填充颜色\nText-stroke-width: 文字边界宽度</p>\n<p>gradient 渐变效果\n线性渐变 linear左上（0% 0%）到右上(0% 100%)</p>\n<p>background-image:-webkit-gradient(linear,0% 0%,100% 0%,form(red),to(balck))</p>\n<p>background-image:-webkit-gradient(linear,0% 0%,100% 0%,from(#2A8BBE),\ncolor-stop(0.33,#AAD010),color-stop(0.33,#FF7F00),to(#FE280E));</p>\n<p>径向渐变radial从一个圆到一个圆的渐变\nbackground:-weblit-gradient(radial,50 50,50,50 50,0,form(black),color-stop(0.5,red),to(blue));</p>\n<p>css3的阴影shadow和反射reflect</p>\n<p>background-clip:border-box;背景从border开始显示；\nbackground-clip：padding-box\nbackground-clip：content-box\nbackground-clip:no-clip:no-clicp默认属性等同于border-box</p>\n<p>background-origin 用于确定背景的位置 通常与background-positon联合使用</p>\n<p>background-size来调整背景图片的大小，注意别和 clip 弄混，这个主要用于设定图片本身</p>\n<p>background-size: contain; 缩小图片以适合元素（维持像素长宽比）\nbackground-size: cover; 扩展元素以填补元素（维持像素长宽比）\nbackground-size: 100px 100px; 缩小图片至指定的大小 .\nbackground-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包    含元素的尺寸</p>\n<p>background-break: continuous; 默认值。忽略盒之间的距离（也就是像元    素没有分成多个盒子，依然是 \n一个整体一    样）\nbackground-break: bounding-box; 把盒之间的距离计算在内；\nbackground-break: each-box; 为每个盒子单独重绘背景</p>\n<p>counter()=[counter(name) | counters(name,list-style-type)]{1,}</p>\n<p>counter-reset IE8</p>\n<p>counter-reset 属性设置某个选择器出现次数的计数器的值。默认为 0。\n利用这个属性，计数器可以设置或重置为任何值，可以是正值或负值。如果没有提供 number，则默认为 0。\n注释：如果使用 &quot;display: none&quot;，则无法重置计数器。如果使用 &quot;visibility: hidden&quot;，则可以重置计数器</p>\n<p>JavaScript 语法：    object.style.counterReset=&quot;subsection&quot;</p>\n<p>counter-reset的值none id number inherit</p>\n<p>attr()=attr(attr-name)插入元素的属性值 IE8</p>\n<p>calc() =calc(四则运算) 动态计算长度值 IE9\n需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；\ncalc()函数支持 &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot; 运算；\ncalc()函数使用标准的数学运算优先级规则；</p>\n<p>initial属于css-wide关键字，这表示所有的属性都可以接受该值 IE11</p>\n<p>unset 擦除属性声明</p>\n<p>颜色值\ncolor color的颜色名称，HEX，RGB，RGBA，HSL，HSLA，transparent,currentColor</p>\n<p>currentColor</p>\n<p>resolution分辨率值不允许有负值\n频率单位包括有： dpi, dpcm, dppx</p>\n<p>角度值 angle角度值的正常范围应在[0-360deg]内，例如：-10deg与350deg是等价的\n角度单位包括有： deg, grad一个圆共400梯度, rad 一个圆共2π弧度, turn\n90deg = 100grad = 0.25turn ≈ 1.570796326794897rad</p>\n<p>长度值与单位</p>\n<p>ch 数字“0”的宽度 ie9</p>\n<p>rem 相对长度单位。相对于根元素(即html元素)font-size计算值的倍数\nvw相对于视口的宽度。视口被均分为100单位的vw ie9\nvh 相对于视口的高度。视口被均分为100单位的vh\nvmax 相对于视口的宽度或高度中较大的那个。其中最大的那个被均分为100单位的vmax\nvmin相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin\nq 1/4毫米（quarter-millimeters）。绝对长度单位。\n1in = 2.54cm = 25.4 mm = 101.6q = 72pt = 6pc = 96px</p>\n<p>@import@media@font-face@keyframes@supports</p>\n<p>E:first-letter/E::first-letter\nE:first-line/E::first-line\nE:before/E::before\nE:after/E::after\nE::placeholderE::selection</p>\n<p>E:not(s)\nE:root\nE:last-child\nE:only-child\nE:nth-child(n)\nE:nth-last-child(n)\nE:first-of-type\nE:last-of-type\nE:only-of-type\nE:nth-of-type(n)\nE:nth-last-of-type(n)\nE:empty\nE:checked\nE:enabled\nE:disabled\nE:target</p>\n<p>属性选择器\nE[att^=&quot;val&quot;]选择具有att属性且属性值为以val开头的字符串的E元素\nE[att$=&quot;val&quot;]选择具有att属性且属性值为以val结尾的字符串的E元素\nE[att*=&quot;val&quot;]选择具有att属性且属性值为包含val的字符串的E元素</p>\n<p>E~F</p>\n<p>CSS3 的盒子模型\n盒子模型为开发者提供了一种非常灵活的布局方式，但是支持这一特性的浏览器并不多，目前只有 webkit 内核的新版本 safari 和 chrome 以及 gecko 内核的新版本 firefox</p>\n", "createdAt" : { "$date" : "2019-10-06T15:23:57.380+0000" }, "updatedAt" : { "$date" : "2019-10-11T16:29:41.959+0000" }, "__v" : 0, "intro" : "盒子模型为开发者提供了一种非常灵活的布局方式，但是支持这一特性的浏览器并不多，目前只有 webkit 内核的新版本 safari 和 chrome 以及 gecko 内核的新版本 firefox" }


